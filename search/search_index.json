{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"api/","title":"API Reference","text":""},{"location":"api/#common","title":"Common","text":"<p>General functions and classes used by other modules.</p>"},{"location":"api/#scenery.common.CustomDiscoverRunner","title":"<code>CustomDiscoverRunner</code>","text":"<p>               Bases: <code>DiscoverRunner</code></p> <p>Custom test runner that allows for stream capture.</p> Source code in <code>scenery/common.py</code> <pre><code>class CustomDiscoverRunner(DjangoDiscoverRunner):\n    \"\"\"Custom test runner that allows for stream capture.\"\"\"\n\n    # NOTE mad: this was done to potentially shut down the original stream\n    # NOTE mad: used both in rehearsal and core module (for the runner\n    # TODO mad: once we fit FastAPI, this runner should only be used \n    # for the django backend and frontend test\n\n    def __init__(self, stream: typing.Any , *args: typing.Any, **kwargs: typing.Any) -&gt; None:\n        super().__init__(*args, **kwargs)\n        self.stream = stream\n\n    # def __del__(self):\n    #     print(self.stream.getvalue())\n\n    def get_test_runner_kwargs(self) -&gt; dict[str, typing.Any]:\n        \"\"\"Overwrite the original from django.test.runner.DiscoverRunner.\"\"\"\n        return overwrite_get_runner_kwargs(self, self.stream)\n</code></pre>"},{"location":"api/#scenery.common.CustomDiscoverRunner.get_test_runner_kwargs","title":"<code>get_test_runner_kwargs()</code>","text":"<p>Overwrite the original from django.test.runner.DiscoverRunner.</p> Source code in <code>scenery/common.py</code> <pre><code>def get_test_runner_kwargs(self) -&gt; dict[str, typing.Any]:\n    \"\"\"Overwrite the original from django.test.runner.DiscoverRunner.\"\"\"\n    return overwrite_get_runner_kwargs(self, self.stream)\n</code></pre>"},{"location":"api/#scenery.common.DjangoBackendTestCase","title":"<code>DjangoBackendTestCase</code>","text":"<p>               Bases: <code>TestCase</code></p> <p>A Django TestCase for backend testing.</p> Source code in <code>scenery/common.py</code> <pre><code>class DjangoBackendTestCase(django.test.TestCase):\n    \"\"\"A Django TestCase for backend testing.\"\"\"\n</code></pre>"},{"location":"api/#scenery.common.DjangoFrontendTestCase","title":"<code>DjangoFrontendTestCase</code>","text":"<p>               Bases: <code>StaticLiveServerTestCase</code></p> <p>A Django TestCase for frontend testing.</p> Source code in <code>scenery/common.py</code> <pre><code>class DjangoFrontendTestCase(StaticLiveServerTestCase):\n    \"\"\"A Django TestCase for frontend testing.\"\"\"\n    base_url: str\n    driver: webdriver.Chrome\n</code></pre>"},{"location":"api/#scenery.common.LoadTestCase","title":"<code>LoadTestCase</code>","text":"<p>               Bases: <code>TestCase</code></p> <p>A TestCase for load testing on a remote server.</p> Source code in <code>scenery/common.py</code> <pre><code>class LoadTestCase(unittest.TestCase):\n    \"\"\"A TestCase for load testing on a remote server.\"\"\"\n    mode: str\n    session: requests.Session\n    headers: dict[str, str]\n    base_url: str\n    data: dict[str, typing.List[dict[str, int|float]]]\n    users:int\n    requests_per_user:int\n</code></pre>"},{"location":"api/#scenery.common.RemoteBackendTestCase","title":"<code>RemoteBackendTestCase</code>","text":"<p>               Bases: <code>TestCase</code></p> <p>A TestCase for backend testing on a remote server.</p> Source code in <code>scenery/common.py</code> <pre><code>class RemoteBackendTestCase(unittest.TestCase):\n    \"\"\"A TestCase for backend testing on a remote server.\"\"\"\n    mode: str\n    session: requests.Session\n    base_url: str\n    headers: dict[str, str]\n</code></pre>"},{"location":"api/#scenery.common.RemoteFrontendTestCase","title":"<code>RemoteFrontendTestCase</code>","text":"<p>               Bases: <code>TestCase</code></p> <p>A TestCase for backend testing on a remote server.</p> Source code in <code>scenery/common.py</code> <pre><code>class RemoteFrontendTestCase(unittest.TestCase):\n    \"\"\"A TestCase for backend testing on a remote server.\"\"\"\n    mode: str\n    driver: webdriver.Chrome\n    # session: requests.Session\n    base_url: str\n    headers: dict[str, str]\n</code></pre>"},{"location":"api/#scenery.common.get_selenium_driver","title":"<code>get_selenium_driver(headless)</code>","text":"<p>Return a Selenium WebDriver instance configured for Chrome.</p> Source code in <code>scenery/common.py</code> <pre><code>def get_selenium_driver(headless: bool) -&gt; webdriver.Chrome:\n    \"\"\"Return a Selenium WebDriver instance configured for Chrome.\"\"\"\n    chrome_options = Options()\n    chrome_options.add_argument('--no-sandbox')\n    chrome_options.add_argument('--disable-dev-shm-usage')\n    chrome_options.add_argument('--disable-gpu')\n    chrome_options.add_argument('--window-size=1920,1080')\n    chrome_options.add_argument('--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36')\n    if headless:\n        chrome_options.add_argument(\"--headless=new\")         # NOTE mad: For newer Chrome versions\n        # chrome_options.add_argument(\"--headless\")           \n    driver = webdriver.Chrome(options=chrome_options)  #  service=service\n    driver.implicitly_wait(10)\n    return driver\n</code></pre>"},{"location":"api/#scenery.common.interpret","title":"<code>interpret(success)</code>","text":"<p>Return emojy, success/failure message, color and log level corresponding to the succes of an execution.</p> Source code in <code>scenery/common.py</code> <pre><code>def interpret(success: bool) -&gt; typing.Tuple[str, str, str, int]:\n    \"\"\"Return emojy, success/failure message, color and log level corresponding to the succes of an execution.\"\"\"\n    if success:\n        emojy, msg, color, log_lvl = \"\ud83d\udfe2\", \"passed\", \"green\", logging.INFO\n    else:\n        emojy, msg, color, log_lvl = \"\u274c\", \"failed\", \"red\", logging.ERROR\n    return emojy, msg, color, log_lvl\n</code></pre>"},{"location":"api/#scenery.common.overwrite_get_runner_kwargs","title":"<code>overwrite_get_runner_kwargs(django_runner, stream)</code>","text":"<p>Overwrite the get_runner_kwargs method of Django's DiscoverRunner.</p> <p>This function is used to avoid printing Django test output by redirecting the stream.</p> <p>Parameters:</p> Name Type Description Default <code>django_runner</code> <code>DiscoverRunner</code> <p>The Django test runner instance.</p> required <code>stream</code> <code>IO</code> <p>The stream to redirect output to.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>A dictionary of keyword arguments for the test runner.</p> Notes <p>see django.test.runner.DiscoverRunner.get_runner_kwargs</p> Source code in <code>scenery/common.py</code> <pre><code>def overwrite_get_runner_kwargs(\n    django_runner: DjangoDiscoverRunner, stream: typing.IO\n) -&gt; dict[str, typing.Any]:\n    \"\"\"Overwrite the get_runner_kwargs method of Django's DiscoverRunner.\n\n    This function is used to avoid printing Django test output by redirecting the stream.\n\n    Args:\n        django_runner (DiscoverRunner): The Django test runner instance.\n        stream: The stream to redirect output to.\n\n    Returns:\n        dict: A dictionary of keyword arguments for the test runner.\n\n    Notes:\n        see django.test.runner.DiscoverRunner.get_runner_kwargs\n    \"\"\"\n    kwargs = {\n        \"failfast\": django_runner.failfast,\n        \"resultclass\": django_runner.get_resultclass(),\n        \"verbosity\": django_runner.verbosity,\n        \"buffer\": django_runner.buffer,\n        # NOTE: this is the line below that changes compared to the original\n        \"stream\": stream,\n    }\n    return kwargs\n</code></pre>"},{"location":"api/#scenery.common.read_yaml","title":"<code>read_yaml(filename)</code>","text":"<p>Read and parse a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the YAML file to be read.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The parsed content of the YAML file.</p> <p>Raises:</p> Type Description <code>YAMLError</code> <p>If there's an error parsing the YAML file.</p> <code>IOError</code> <p>If there's an error reading the file.</p> Source code in <code>scenery/common.py</code> <pre><code>def read_yaml(filename: str) -&gt; typing.Any:\n    \"\"\"Read and parse a YAML file.\n\n    Args:\n        filename (str): The path to the YAML file to be read.\n\n    Returns:\n        Any: The parsed content of the YAML file.\n\n    Raises:\n        yaml.YAMLError: If there's an error parsing the YAML file.\n        IOError: If there's an error reading the file.\n    \"\"\"\n    with open(filename, \"r\") as f:\n        return yaml.safe_load(f)\n</code></pre>"},{"location":"api/#scenery.common.serialize_unittest_result","title":"<code>serialize_unittest_result(result)</code>","text":"<p>Serialize a unittest.TestResult object into a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>TestResult</code> <p>The TestResult object to serialize.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Counter</code> <p>A dictionary containing the serialized TestResult data.</p> Source code in <code>scenery/common.py</code> <pre><code>def serialize_unittest_result(result: unittest.TestResult) -&gt; Counter:\n    \"\"\"Serialize a unittest.TestResult object into a dictionary.\n\n    Args:\n        result (unittest.TestResult): The TestResult object to serialize.\n\n    Returns:\n        dict: A dictionary containing the serialized TestResult data.\n    \"\"\"\n    d = {\n        attr: getattr(result, attr)\n        for attr in [\n            \"failures\",\n            \"errors\",\n            \"testsRun\",\n            \"skipped\",\n            \"expectedFailures\",\n            \"unexpectedSuccesses\",\n        ]\n    }\n    d = {key: len(val) if isinstance(val, list) else val for key, val in d.items()}\n    return Counter(d)\n</code></pre>"},{"location":"api/#scenery.common.summarize_test_result","title":"<code>summarize_test_result(result, test_label)</code>","text":"<p>Return true if the tests all succeeded, false otherwise.</p> Source code in <code>scenery/common.py</code> <pre><code>def summarize_test_result(result: unittest.TestResult, test_label: str) -&gt; tuple[bool, Counter]:\n    \"\"\"Return true if the tests all succeeded, false otherwise.\"\"\"\n    for failed_test, traceback in result.failures:\n        test_name = failed_test.id()\n        emojy, msg, color, log_lvl = interpret(False)\n        # logger.log(log_lvl, f\"[{color}]{test_name} {msg}[/{color}]\\n{traceback}\")\n        logger.log(log_lvl, f\"{test_name} {msg}\", style=color)\n        # console.print_exception(\n        #     exc_info=(None, None, traceback),\n        #     show_locals=True\n        # )\n        console.print(traceback)\n\n    for failed_test, traceback in result.errors:\n        test_name = failed_test.id()\n        emojy, msg, color, log_lvl = interpret(False)\n        # logger.log(log_lvl, f\"[{color}]{test_name} {msg}[/{color}]\\n{traceback}\")\n        logger.log(log_lvl, f\"{test_name} {msg}\", style=color)\n        console.print(traceback)\n\n    success = True\n    summary = serialize_unittest_result(result)\n    if summary[\"errors\"] &gt; 0 or summary[\"failures\"] &gt; 0:\n        success = False\n    if summary[\"testsRun\"] == 0:\n        pass\n\n    else:\n        emojy, msg, color, log_lvl = interpret(success)\n        msg = f\"{test_label} {msg}\"\n        logger.log(log_lvl, msg, style=color)\n\n    return success, summary\n</code></pre>"},{"location":"api/#core","title":"Core","text":"<p>Build the tests from the Manifest, discover &amp; run tests.</p>"},{"location":"api/#scenery.core.MetaTest","title":"<code>MetaTest</code>","text":"<p>               Bases: <code>type</code></p> <p>A metaclass for creating test classes dynamically based on a Manifest.</p> <p>This metaclass creates test methods for each combination of case and scene in the manifest, and adds setup methods to the test class.</p> Source code in <code>scenery/core.py</code> <pre><code>class MetaTest(type):\n    \"\"\"\n    A metaclass for creating test classes dynamically based on a Manifest.\n\n    This metaclass creates test methods for each combination of case and scene in the manifest,\n    and adds setup methods to the test class.\n    \"\"\"\n\n    def __new__(\n        cls,\n        clsname: str,\n        bases: tuple[type],\n        manifest: Manifest,\n        mode: str | None = None,\n        only_case_id: str | None = None,\n        only_scene_pos: str | None = None,\n        only_url: str | None = None,\n        driver: webdriver.Chrome | None=None,\n        users: int | None=None,\n        requests_per_user: int | None=None,\n    ) -&gt; \"MetaTest\":\n        \"\"\"Responsible for building the TestCase class.\n\n        Args:\n            clsname (str): The name of the class being created.\n            bases (tuple): The base classes of the class being created.\n            manifest (Manifest): The manifest containing test cases and scenes.\n\n        Returns:\n            type: A new test class with dynamically created test methods.\n\n        Raises:\n            ValueError: If the restrict argument is not in the correct format.\n        \"\"\"\n\n        # Build setUp and tearDown functions\n        ####################################\n\n        # NOTE mad: setUpTestData would be a pain since LoadTestCase and RemoteTestCase \n        # are not suppoesed to work with\n        setUpClass = MethodBuilder.build_setUpClass(manifest.set_up_class, driver)\n        setUp = MethodBuilder.build_setUp(manifest.set_up)\n\n        cls_attrs = {\n            \"setUpClass\": setUpClass,\n            \"setUp\": setUp,\n            \"mode\": mode,\n        }\n        if users:\n            cls_attrs[\"users\"] = users\n        if requests_per_user:\n            cls_attrs[\"requests_per_user\"] = requests_per_user\n\n        if bases == (DjangoFrontendTestCase,) or bases == (RemoteFrontendTestCase,):\n            # NOTE mad: used to close the driver\n            tearDownClass = MethodBuilder.build_tearDownClass()\n            cls_attrs[\"tearDownClass\"] = tearDownClass\n\n\n        # Add test_* functions\n        ####################################\n\n        for case_id, scene_pos, take in manifest.iter_on_takes(\n            only_url,\n            only_case_id,\n            only_scene_pos,\n        ):\n            if bases in [\n                (DjangoBackendTestCase,),\n                (DjangoFrontendTestCase,),\n                (RemoteBackendTestCase,),\n                (RemoteFrontendTestCase,),\n            ] :\n                test = MethodBuilder.build_test_integration(take)\n            elif bases == (LoadTestCase,):\n                test = MethodBuilder.build_test_load(take)\n            else:\n                raise NotImplementedError(bases)\n            cls_attrs.update({f\"test_case_{case_id}_scene_{scene_pos}\": test})\n\n        test_cls = super().__new__(cls, clsname, bases, cls_attrs)\n        return test_cls  \n</code></pre>"},{"location":"api/#scenery.core.MetaTest.__new__","title":"<code>__new__(clsname, bases, manifest, mode=None, only_case_id=None, only_scene_pos=None, only_url=None, driver=None, users=None, requests_per_user=None)</code>","text":"<p>Responsible for building the TestCase class.</p> <p>Parameters:</p> Name Type Description Default <code>clsname</code> <code>str</code> <p>The name of the class being created.</p> required <code>bases</code> <code>tuple</code> <p>The base classes of the class being created.</p> required <code>manifest</code> <code>Manifest</code> <p>The manifest containing test cases and scenes.</p> required <p>Returns:</p> Name Type Description <code>type</code> <code>MetaTest</code> <p>A new test class with dynamically created test methods.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the restrict argument is not in the correct format.</p> Source code in <code>scenery/core.py</code> <pre><code>def __new__(\n    cls,\n    clsname: str,\n    bases: tuple[type],\n    manifest: Manifest,\n    mode: str | None = None,\n    only_case_id: str | None = None,\n    only_scene_pos: str | None = None,\n    only_url: str | None = None,\n    driver: webdriver.Chrome | None=None,\n    users: int | None=None,\n    requests_per_user: int | None=None,\n) -&gt; \"MetaTest\":\n    \"\"\"Responsible for building the TestCase class.\n\n    Args:\n        clsname (str): The name of the class being created.\n        bases (tuple): The base classes of the class being created.\n        manifest (Manifest): The manifest containing test cases and scenes.\n\n    Returns:\n        type: A new test class with dynamically created test methods.\n\n    Raises:\n        ValueError: If the restrict argument is not in the correct format.\n    \"\"\"\n\n    # Build setUp and tearDown functions\n    ####################################\n\n    # NOTE mad: setUpTestData would be a pain since LoadTestCase and RemoteTestCase \n    # are not suppoesed to work with\n    setUpClass = MethodBuilder.build_setUpClass(manifest.set_up_class, driver)\n    setUp = MethodBuilder.build_setUp(manifest.set_up)\n\n    cls_attrs = {\n        \"setUpClass\": setUpClass,\n        \"setUp\": setUp,\n        \"mode\": mode,\n    }\n    if users:\n        cls_attrs[\"users\"] = users\n    if requests_per_user:\n        cls_attrs[\"requests_per_user\"] = requests_per_user\n\n    if bases == (DjangoFrontendTestCase,) or bases == (RemoteFrontendTestCase,):\n        # NOTE mad: used to close the driver\n        tearDownClass = MethodBuilder.build_tearDownClass()\n        cls_attrs[\"tearDownClass\"] = tearDownClass\n\n\n    # Add test_* functions\n    ####################################\n\n    for case_id, scene_pos, take in manifest.iter_on_takes(\n        only_url,\n        only_case_id,\n        only_scene_pos,\n    ):\n        if bases in [\n            (DjangoBackendTestCase,),\n            (DjangoFrontendTestCase,),\n            (RemoteBackendTestCase,),\n            (RemoteFrontendTestCase,),\n        ] :\n            test = MethodBuilder.build_test_integration(take)\n        elif bases == (LoadTestCase,):\n            test = MethodBuilder.build_test_load(take)\n        else:\n            raise NotImplementedError(bases)\n        cls_attrs.update({f\"test_case_{case_id}_scene_{scene_pos}\": test})\n\n    test_cls = super().__new__(cls, clsname, bases, cls_attrs)\n    return test_cls  \n</code></pre>"},{"location":"api/#scenery.core.TestsDiscoverer","title":"<code>TestsDiscoverer</code>","text":"<p>A class for discovering and loading test cases from manifest files.</p> <p>This class scans a directory for manifest files, creates test classes from these manifests, and loads the tests into test suites.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>Logger</code> <p>A logger instance for this class.</p> <code>runner</code> <code>DiscoverRunner</code> <p>A Django test runner instance.</p> <code>loader</code> <code>TestLoader</code> <p>A test loader instance from the runner.</p> Source code in <code>scenery/core.py</code> <pre><code>class TestsDiscoverer:\n    \"\"\"\n    A class for discovering and loading test cases from manifest files.\n\n    This class scans a directory for manifest files, creates test classes from these manifests,\n    and loads the tests into test suites.\n\n    Attributes:\n        logger (Logger): A logger instance for this class.\n        runner (DiscoverRunner): A Django test runner instance.\n        loader (TestLoader): A test loader instance from the runner.\n    \"\"\"\n\n    # NOTE mad: I redefine this for multithreading possibilities\n    # sadly this failed but I still think it is a better pattern\n\n\n    runner = get_runner(settings, test_runner_class=\"django.test.runner.DiscoverRunner\")()\n    loader: unittest.loader.TestLoader = runner.test_loader\n\n    @property\n    def folder(self) -&gt; str:\n        return os.environ[\"SCENERY_MANIFESTS_FOLDER\"]\n\n    def integration_tests_from_manifest(\n        self,\n        filename: str,\n        mode: str,\n        back: bool = False,\n        front: bool = False,\n        only_url: str | None = None,\n        timeout_waiting_time: int = 5,\n        only_case_id: str | None = None,\n        only_scene_pos: str | None = None,\n        driver: webdriver.Chrome | None = None,\n        headless: bool = True,\n    ) -&gt; Tuple[unittest.TestSuite, unittest.TestSuite, unittest.TestSuite, unittest.TestSuite]:\n        \"\"\"Creates test suites from a manifest file for both backend and frontend testing.\n\n        Parses a YAML manifest file and generates corresponding test suites for backend\n        and frontend testing. Tests can be filtered based on various criteria like test type,\n        specific views, or test cases.\n\n        Args:\n            filename (str): The name of the YAML manifest file to parse.\n            only_back (bool, optional): Run only backend tests. Defaults to False.\n            only_front (bool, optional): Run only frontend tests. Defaults to False.\n            only_url (str, optional): Filter tests to run only for a specific view. Defaults to None.\n            timeout_waiting_time (int, optional): Timeout duration for frontend tests in seconds. Defaults to 5.\n            only_case_id (str, optional): Filter tests to run only for a specific case ID. Defaults to None.\n            only_scene_pos (str, optional): Filter tests to run only for a specific scene position. Defaults to None.\n            driver (webdriver.Chrome, optional): Selenium Chrome WebDriver instance. If None, creates new instance. Defaults to None.\n            headless (bool, optional): Whether to run browser in headless mode. Defaults to True.\n\n        Returns:\n            Tuple[unittest.TestSuite, unittest.TestSuite]: A tuple containing:\n                - Backend test suite (first element)\n                - Frontend test suite (second element)\n\n        Notes:\n            - The manifest's ttype determines which suites are created (backend, frontend, or both)\n            - Empty test suites are returned for disabled test types\n            - The driver initialization can occur here or be passed in from external code\n        \"\"\"\n\n        dev_backend_suite, dev_frontend_suite = unittest.TestSuite(), unittest.TestSuite()\n        remote_backend_suite, remote_frontend_suite = unittest.TestSuite(), unittest.TestSuite()\n\n        # Parse manifest\n        manifest = ManifestParser.parse_yaml_from_file(os.path.join(self.folder, filename))\n        ttype = manifest.ttype\n        manifest_name = filename.replace(\".yml\", \"\")\n\n        # NOTE mad: manifests can indicate they are not to be ran in some mode\n        back &amp;= ttype is None or ttype == \"backend\"\n        front &amp;= ttype is None or ttype == \"frontend\"\n\n        if back and mode == \"dev\":\n            cls = MetaTest(\n                f\"{manifest_name}.dev.backend\",\n                (DjangoBackendTestCase,),\n                manifest,\n                only_case_id=only_case_id,\n                only_scene_pos=only_scene_pos,\n                only_url=only_url,\n                mode=mode,\n            )\n            # FIXME mad: type hinting mislead by metaclasses\n            tests = self.loader.loadTestsFromTestCase(cls)  # type: ignore[arg-type]\n            dev_backend_suite.addTests(tests)\n\n        if back and mode in [\"local\", \"staging\", \"prod\"]:\n            cls = MetaTest(\n                f\"{manifest_name}.remote.backend\",\n                (RemoteBackendTestCase,),\n                manifest,\n                only_case_id=only_case_id,\n                only_scene_pos=only_scene_pos,\n                only_url=only_url,\n                mode=mode\n            )\n\n            # FIXME mad: type hinting mislead by metaclasses\n            tests = self.loader.loadTestsFromTestCase(cls) # type: ignore[arg-type]\n            remote_backend_suite.addTests(tests)\n\n        # Create frontend test\n        if front and mode == \"dev\":\n            # NOTE mad: this is here to be able to load driver in two places\n            # See also scenery/__main__.py\n            # Probably not a great pattern but let's FIXME this later\n            if driver is None:\n                driver = get_selenium_driver(headless=headless)\n\n            cls = MetaTest(\n                f\"{manifest_name}.dev.frontend\",\n                (DjangoFrontendTestCase,),\n                manifest,\n                only_case_id=only_case_id,\n                only_scene_pos=only_scene_pos,\n                only_url=only_url,\n                driver=driver,\n                mode=mode,\n            )\n            # FIXME mad: type hinting mislead by metaclasses\n            tests = self.loader.loadTestsFromTestCase(cls)  # type: ignore[arg-type]\n            dev_frontend_suite.addTests(tests)\n\n\n        if front and mode in [\"local\", \"staging\", \"prod\"]:\n            cls = MetaTest(\n                f\"{manifest_name}.remote.frontend\",\n                (RemoteFrontendTestCase,),\n                manifest,\n                only_case_id=only_case_id,\n                only_scene_pos=only_scene_pos,\n                only_url=only_url,\n                driver=driver,\n                mode=mode\n            )\n\n            # FIXME mad: type hinting mislead by metaclasses\n            tests = self.loader.loadTestsFromTestCase(cls) # type: ignore[arg-type]\n            remote_frontend_suite.addTests(tests)\n\n        return dev_backend_suite, dev_frontend_suite, remote_backend_suite, remote_frontend_suite\n\n\n    def load_tests_from_manifest(\n        self,\n        filename: str,\n        mode: str,\n        users: int,\n        requests_per_user: int,\n        only_url: str | None = None,\n        only_case_id: str | None = None,\n        only_scene_pos: str | None = None,\n    ) -&gt; unittest.TestSuite:\n\n        test_suite = unittest.TestSuite()\n\n        # Parse manifest\n        manifest = ManifestParser.parse_yaml_from_file(os.path.join(self.folder, filename))\n        manifest_name = filename.replace(\".yml\", \"\")\n\n        cls = MetaTest(\n            f\"{manifest_name}.load\",\n            (LoadTestCase,),\n            manifest,\n            only_case_id=only_case_id,\n            only_scene_pos=only_scene_pos,\n            only_url=only_url,\n            mode=mode,\n            users=users,\n            requests_per_user=requests_per_user\n        )\n\n        # FIXME mad: type hinting mislead by metaclasses\n        tests = self.loader.loadTestsFromTestCase(cls)  # type: ignore[arg-type]\n        test_suite.addTests(tests)\n\n        return test_suite\n</code></pre>"},{"location":"api/#scenery.core.TestsDiscoverer.integration_tests_from_manifest","title":"<code>integration_tests_from_manifest(filename, mode, back=False, front=False, only_url=None, timeout_waiting_time=5, only_case_id=None, only_scene_pos=None, driver=None, headless=True)</code>","text":"<p>Creates test suites from a manifest file for both backend and frontend testing.</p> <p>Parses a YAML manifest file and generates corresponding test suites for backend and frontend testing. Tests can be filtered based on various criteria like test type, specific views, or test cases.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the YAML manifest file to parse.</p> required <code>only_back</code> <code>bool</code> <p>Run only backend tests. Defaults to False.</p> required <code>only_front</code> <code>bool</code> <p>Run only frontend tests. Defaults to False.</p> required <code>only_url</code> <code>str</code> <p>Filter tests to run only for a specific view. Defaults to None.</p> <code>None</code> <code>timeout_waiting_time</code> <code>int</code> <p>Timeout duration for frontend tests in seconds. Defaults to 5.</p> <code>5</code> <code>only_case_id</code> <code>str</code> <p>Filter tests to run only for a specific case ID. Defaults to None.</p> <code>None</code> <code>only_scene_pos</code> <code>str</code> <p>Filter tests to run only for a specific scene position. Defaults to None.</p> <code>None</code> <code>driver</code> <code>Chrome</code> <p>Selenium Chrome WebDriver instance. If None, creates new instance. Defaults to None.</p> <code>None</code> <code>headless</code> <code>bool</code> <p>Whether to run browser in headless mode. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Tuple[TestSuite, TestSuite, TestSuite, TestSuite]</code> <p>Tuple[unittest.TestSuite, unittest.TestSuite]: A tuple containing: - Backend test suite (first element) - Frontend test suite (second element)</p> Notes <ul> <li>The manifest's ttype determines which suites are created (backend, frontend, or both)</li> <li>Empty test suites are returned for disabled test types</li> <li>The driver initialization can occur here or be passed in from external code</li> </ul> Source code in <code>scenery/core.py</code> <pre><code>def integration_tests_from_manifest(\n    self,\n    filename: str,\n    mode: str,\n    back: bool = False,\n    front: bool = False,\n    only_url: str | None = None,\n    timeout_waiting_time: int = 5,\n    only_case_id: str | None = None,\n    only_scene_pos: str | None = None,\n    driver: webdriver.Chrome | None = None,\n    headless: bool = True,\n) -&gt; Tuple[unittest.TestSuite, unittest.TestSuite, unittest.TestSuite, unittest.TestSuite]:\n    \"\"\"Creates test suites from a manifest file for both backend and frontend testing.\n\n    Parses a YAML manifest file and generates corresponding test suites for backend\n    and frontend testing. Tests can be filtered based on various criteria like test type,\n    specific views, or test cases.\n\n    Args:\n        filename (str): The name of the YAML manifest file to parse.\n        only_back (bool, optional): Run only backend tests. Defaults to False.\n        only_front (bool, optional): Run only frontend tests. Defaults to False.\n        only_url (str, optional): Filter tests to run only for a specific view. Defaults to None.\n        timeout_waiting_time (int, optional): Timeout duration for frontend tests in seconds. Defaults to 5.\n        only_case_id (str, optional): Filter tests to run only for a specific case ID. Defaults to None.\n        only_scene_pos (str, optional): Filter tests to run only for a specific scene position. Defaults to None.\n        driver (webdriver.Chrome, optional): Selenium Chrome WebDriver instance. If None, creates new instance. Defaults to None.\n        headless (bool, optional): Whether to run browser in headless mode. Defaults to True.\n\n    Returns:\n        Tuple[unittest.TestSuite, unittest.TestSuite]: A tuple containing:\n            - Backend test suite (first element)\n            - Frontend test suite (second element)\n\n    Notes:\n        - The manifest's ttype determines which suites are created (backend, frontend, or both)\n        - Empty test suites are returned for disabled test types\n        - The driver initialization can occur here or be passed in from external code\n    \"\"\"\n\n    dev_backend_suite, dev_frontend_suite = unittest.TestSuite(), unittest.TestSuite()\n    remote_backend_suite, remote_frontend_suite = unittest.TestSuite(), unittest.TestSuite()\n\n    # Parse manifest\n    manifest = ManifestParser.parse_yaml_from_file(os.path.join(self.folder, filename))\n    ttype = manifest.ttype\n    manifest_name = filename.replace(\".yml\", \"\")\n\n    # NOTE mad: manifests can indicate they are not to be ran in some mode\n    back &amp;= ttype is None or ttype == \"backend\"\n    front &amp;= ttype is None or ttype == \"frontend\"\n\n    if back and mode == \"dev\":\n        cls = MetaTest(\n            f\"{manifest_name}.dev.backend\",\n            (DjangoBackendTestCase,),\n            manifest,\n            only_case_id=only_case_id,\n            only_scene_pos=only_scene_pos,\n            only_url=only_url,\n            mode=mode,\n        )\n        # FIXME mad: type hinting mislead by metaclasses\n        tests = self.loader.loadTestsFromTestCase(cls)  # type: ignore[arg-type]\n        dev_backend_suite.addTests(tests)\n\n    if back and mode in [\"local\", \"staging\", \"prod\"]:\n        cls = MetaTest(\n            f\"{manifest_name}.remote.backend\",\n            (RemoteBackendTestCase,),\n            manifest,\n            only_case_id=only_case_id,\n            only_scene_pos=only_scene_pos,\n            only_url=only_url,\n            mode=mode\n        )\n\n        # FIXME mad: type hinting mislead by metaclasses\n        tests = self.loader.loadTestsFromTestCase(cls) # type: ignore[arg-type]\n        remote_backend_suite.addTests(tests)\n\n    # Create frontend test\n    if front and mode == \"dev\":\n        # NOTE mad: this is here to be able to load driver in two places\n        # See also scenery/__main__.py\n        # Probably not a great pattern but let's FIXME this later\n        if driver is None:\n            driver = get_selenium_driver(headless=headless)\n\n        cls = MetaTest(\n            f\"{manifest_name}.dev.frontend\",\n            (DjangoFrontendTestCase,),\n            manifest,\n            only_case_id=only_case_id,\n            only_scene_pos=only_scene_pos,\n            only_url=only_url,\n            driver=driver,\n            mode=mode,\n        )\n        # FIXME mad: type hinting mislead by metaclasses\n        tests = self.loader.loadTestsFromTestCase(cls)  # type: ignore[arg-type]\n        dev_frontend_suite.addTests(tests)\n\n\n    if front and mode in [\"local\", \"staging\", \"prod\"]:\n        cls = MetaTest(\n            f\"{manifest_name}.remote.frontend\",\n            (RemoteFrontendTestCase,),\n            manifest,\n            only_case_id=only_case_id,\n            only_scene_pos=only_scene_pos,\n            only_url=only_url,\n            driver=driver,\n            mode=mode\n        )\n\n        # FIXME mad: type hinting mislead by metaclasses\n        tests = self.loader.loadTestsFromTestCase(cls) # type: ignore[arg-type]\n        remote_frontend_suite.addTests(tests)\n\n    return dev_backend_suite, dev_frontend_suite, remote_backend_suite, remote_frontend_suite\n</code></pre>"},{"location":"api/#scenery.core.TestsRunner","title":"<code>TestsRunner</code>","text":"<p>A class for running discovered tests and collecting results.</p> <p>This class takes discovered tests, runs them using a Django test runner, and collects and formats the results.</p> <p>Attributes:</p> Name Type Description <code>runner</code> <code>DiscoverRunner</code> <p>A Django test runner instance.</p> <code>logger</code> <code>Logger</code> <p>A logger instance for this class.</p> <code>discoverer</code> <code>MetaTestDiscoverer</code> <p>An instance of MetaTestDiscoverer for discovering tests.</p> <code>stream</code> <code>StringIO</code> <p>A string buffer for capturing test output.</p> Source code in <code>scenery/core.py</code> <pre><code>class TestsRunner:\n    \"\"\"\n    A class for running discovered tests and collecting results.\n\n    This class takes discovered tests, runs them using a Django test runner,\n    and collects and formats the results.\n\n    Attributes:\n        runner (DiscoverRunner): A Django test runner instance.\n        logger (Logger): A logger instance for this class.\n        discoverer (MetaTestDiscoverer): An instance of MetaTestDiscoverer for discovering tests.\n        stream (StringIO): A string buffer for capturing test output.\n    \"\"\"\n    # NOTE mad: this was done to potentially shut down the original stream (see also the CustomDiscoverRunner)\n\n    def __init__(self, failfast: bool = False) -&gt; None:\n        \"\"\"Initialize the MetaTestRunner with a runner, logger, discoverer, and output stream.\"\"\"\n\n        # self.stream = io.StringIO()\n        self.stream = sys.stdout\n        self.runner = CustomDiscoverRunner(stream=self.stream, failfast=failfast)\n\n    def __del__(self) -&gt; None:\n        \"\"\"Clean up resources when the MetaTestRunner is deleted.\"\"\"\n        # NOTE mad: do not erase\n        # self.stream.close()\n        # print(self.stream.flush())\n        # app_logger = ...\n        # app_logger.propagate = True\n\n    def run(self, tests_discovered: unittest.TestSuite | unittest.TestCase) -&gt; unittest.TestResult:\n        \"\"\"\n        Run the discovered tests and collect results.\n\n        Args:\n            tests_discovered (list): A list of tuples, each containing a test name and a TestSuite.\n            verbosity (int): The verbosity level for output.\n\n        Returns:\n            dict: A dictionary mapping test names to their serialized results.\n\n        Note:\n            This method logs test results and prints them to the console based on the verbosity level.\n        \"\"\"\n        if isinstance(tests_discovered, unittest.TestCase):\n            # NOTE mad: done for type checking\n            tests_discovered = unittest.TestSuite((tests_discovered,))\n        results = self.runner.run_suite(tests_discovered)\n        return results\n</code></pre>"},{"location":"api/#scenery.core.TestsRunner.__del__","title":"<code>__del__()</code>","text":"<p>Clean up resources when the MetaTestRunner is deleted.</p> Source code in <code>scenery/core.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Clean up resources when the MetaTestRunner is deleted.\"\"\"\n</code></pre>"},{"location":"api/#scenery.core.TestsRunner.__init__","title":"<code>__init__(failfast=False)</code>","text":"<p>Initialize the MetaTestRunner with a runner, logger, discoverer, and output stream.</p> Source code in <code>scenery/core.py</code> <pre><code>def __init__(self, failfast: bool = False) -&gt; None:\n    \"\"\"Initialize the MetaTestRunner with a runner, logger, discoverer, and output stream.\"\"\"\n\n    # self.stream = io.StringIO()\n    self.stream = sys.stdout\n    self.runner = CustomDiscoverRunner(stream=self.stream, failfast=failfast)\n</code></pre>"},{"location":"api/#scenery.core.TestsRunner.run","title":"<code>run(tests_discovered)</code>","text":"<p>Run the discovered tests and collect results.</p> <p>Parameters:</p> Name Type Description Default <code>tests_discovered</code> <code>list</code> <p>A list of tuples, each containing a test name and a TestSuite.</p> required <code>verbosity</code> <code>int</code> <p>The verbosity level for output.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>TestResult</code> <p>A dictionary mapping test names to their serialized results.</p> Note <p>This method logs test results and prints them to the console based on the verbosity level.</p> Source code in <code>scenery/core.py</code> <pre><code>def run(self, tests_discovered: unittest.TestSuite | unittest.TestCase) -&gt; unittest.TestResult:\n    \"\"\"\n    Run the discovered tests and collect results.\n\n    Args:\n        tests_discovered (list): A list of tuples, each containing a test name and a TestSuite.\n        verbosity (int): The verbosity level for output.\n\n    Returns:\n        dict: A dictionary mapping test names to their serialized results.\n\n    Note:\n        This method logs test results and prints them to the console based on the verbosity level.\n    \"\"\"\n    if isinstance(tests_discovered, unittest.TestCase):\n        # NOTE mad: done for type checking\n        tests_discovered = unittest.TestSuite((tests_discovered,))\n    results = self.runner.run_suite(tests_discovered)\n    return results\n</code></pre>"},{"location":"api/#scenery.core.process_manifest_as_integration_test","title":"<code>process_manifest_as_integration_test(manifest_filename, args, driver)</code>","text":"<p>Process a test manifest file and executes both backend and frontend tests.</p> <p>Takes a manifest file and command line arguments to run the specified tests, collecting and summarizing the results for both backend and frontend test suites.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the YAML manifest file to process.</p> required <code>args</code> <code>Namespace</code> <p>Command line arguments containing: - only_back (bool): Run only backend tests - only_front (bool): Run only frontend tests - only_url (str): Filter for specific view - only_case_id (str): Filter for specific case ID - only_scene_pos (str): Filter for specific scene position - timeout_waiting_time (int): Frontend test timeout duration - headless (bool): Whether to run browser in headless mode</p> required <code>driver</code> <code>Chrome | None</code> <p>Selenium Chrome WebDriver instance or None.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Tuple[bool, dict, bool, dict]: A tuple containing: - Backend test success status (bool) - Backend test summary results (dict) - Frontend test success status (bool) - Frontend test summary results (dict)</p> Notes <ul> <li>Prints the manifest name (without .yml extension) during execution</li> <li>Uses TestsLoader and TestsRunner for test execution</li> <li>Test results are summarized with verbosity level 0</li> </ul> Source code in <code>scenery/core.py</code> <pre><code>def process_manifest_as_integration_test(\n    manifest_filename: str, args: argparse.Namespace, driver: webdriver.Chrome | None\n) -&gt; dict:\n    \"\"\"Process a test manifest file and executes both backend and frontend tests.\n\n    Takes a manifest file and command line arguments to run the specified tests,\n    collecting and summarizing the results for both backend and frontend test suites.\n\n    Args:\n        filename (str): The name of the YAML manifest file to process.\n        args (argparse.Namespace): Command line arguments containing:\n            - only_back (bool): Run only backend tests\n            - only_front (bool): Run only frontend tests\n            - only_url (str): Filter for specific view\n            - only_case_id (str): Filter for specific case ID\n            - only_scene_pos (str): Filter for specific scene position\n            - timeout_waiting_time (int): Frontend test timeout duration\n            - headless (bool): Whether to run browser in headless mode\n        driver (webdriver.Chrome | None): Selenium Chrome WebDriver instance or None.\n\n    Returns:\n        Tuple[bool, dict, bool, dict]: A tuple containing:\n            - Backend test success status (bool)\n            - Backend test summary results (dict)\n            - Frontend test success status (bool)\n            - Frontend test summary results (dict)\n\n    Notes:\n        - Prints the manifest name (without .yml extension) during execution\n        - Uses TestsLoader and TestsRunner for test execution\n        - Test results are summarized with verbosity level 0\n    \"\"\"\n\n    # logging.log(logging.INFO, f\"{manifest_filename=}\")\n    logger.info(f\"{manifest_filename=}\")\n\n    loader = TestsDiscoverer()\n    runner = TestsRunner()\n\n    dev_backend_suite, dev_frontend_suite, remote_backend_suite, remote_frontend_suite = (\n        loader.integration_tests_from_manifest(\n            manifest_filename,\n            mode=args.mode,\n            back=args.back,\n            front=args.front,\n            only_url=args.url,\n            only_case_id=args.case_id,\n            only_scene_pos=args.scene_pos,\n            timeout_waiting_time=args.timeout_waiting_time,\n            driver=driver,\n            headless=args.headless,\n        )\n    )\n\n    results: dict[str, unittest.TestResult | None] = {\n        \"dev_backend\": None,\n        \"dev_frontend\": None,\n        \"remote_backend\": None,\n        \"remote_frontend\": None,\n    }\n\n    if args.back and args.mode == \"dev\":\n        results[\"dev_backend\"] = runner.run(dev_backend_suite)\n\n    if args.back and args.mode in [\"local\", \"staging\", \"prod\"]:\n        results[\"remote_backend\"] = runner.run(remote_backend_suite)\n\n    if args.front and args.mode == \"dev\":\n        results[\"dev_frontend\"] = runner.run(dev_frontend_suite)\n\n    if args.front and args.mode in [\"local\", \"staging\", \"prod\"]:\n        results[\"remote_frontend\"] = runner.run(remote_frontend_suite)\n\n    return results\n</code></pre>"},{"location":"api/#manifest-parser","title":"Manifest Parser","text":"<p>Parse manifest YAML files and build proper Manifests.</p>"},{"location":"api/#scenery.manifest_parser.ManifestParser","title":"<code>ManifestParser</code>","text":"<p>A class responsible for parsing test manifest files in YAML format.</p> <p>This class provides methods to validate, format, and parse manifest files into Python objects that can be used by the testing framework.</p> <p>Attributes:</p> Name Type Description <code>common_items</code> <code>dict</code> <p>Common items loaded from a YAML file specified by the SCENERY_COMMON_ITEMS environment variable.</p> Source code in <code>scenery/manifest_parser.py</code> <pre><code>class ManifestParser:\n    \"\"\"\n    A class responsible for parsing test manifest files in YAML format.\n\n    This class provides methods to validate, format, and parse manifest files\n    into Python objects that can be used by the testing framework.\n\n    Attributes:\n        common_items (dict): Common items loaded from a YAML file specified by the SCENERY_COMMON_ITEMS environment variable.\n    \"\"\"\n\n    common_items: dict[str, dict] = scenery.common.read_yaml(os.environ[\"SCENERY_COMMON_ITEMS\"])\n\n    ##########\n    # RAW DICT\n    ##########\n\n    @staticmethod\n    def validate_dict(d: dict) -&gt; None:  # scenery.manifest.RawManifestDict\n        \"\"\"\n        Validate the top-level keys of a manifest dictionary.\n\n        This method checks if only valid keys are present at the top level and ensures\n        that either singular or plural forms of 'case' and 'scene' are provided, but not both.\n\n        Args:\n            d (dict): The manifest dictionary to validate.\n\n        Raises:\n            ValueError: If invalid keys are present or if the case/scene keys are not correctly specified.\n        \"\"\"\n        if not all(\n            key in scenery.manifest.RawManifestDict.__annotations__.keys() for key in d.keys()\n        ):\n            raise ValueError(\n                f\"Invalid key(s) in {d.keys()} ({d.get('manifest_origin', 'No origin found.')})\"\n            )\n\n        for key in [\"case\", \"scene\"]:\n            has_one = key in d\n            has_many = f\"{key}s\" in d\n\n            if has_one and has_many:\n                raise ValueError(\n                    f\"Both `{key}` and `{key}s` keys are present at top level.\",\n                )\n\n            if key == \"scene\" and not (has_one or has_many):\n                raise ValueError(\n                    f\"Neither `{key}` and `{key}s` keys are present at top level.\",\n                )\n\n    @staticmethod\n    def format_dict(d: scenery.manifest.RawManifestDict) -&gt; scenery.manifest.ManifestDict:\n        \"\"\"\n        Reformat the manifest dictionary to ensure it has all expected keys and provide default values if needed.\n\n        Args:\n            d (dict): The original manifest dictionary.\n\n        Returns:\n            dict: A formatted dictionary with all expected keys.\n        \"\"\"\n        return {\n            \"set_up_class\": d.get(\"set_up_class\", []),\n            \"set_up\": d.get(\"set_up\", []),\n            \"scenes\": ManifestParser._format_dict_scenes(d),\n            \"cases\": ManifestParser._format_dict_cases(d),\n            \"manifest_origin\": d[\"manifest_origin\"],\n            \"ttype\": d.get(\"ttype\")\n        }\n\n    @staticmethod\n    def _format_dict_cases(d: scenery.manifest.RawManifestDict) -&gt; dict[str, dict]:\n        has_one = \"case\" in d\n        has_many = \"cases\" in d\n        if has_one:\n            return {\"CASE\": d[\"case\"]}\n        elif has_many:\n            return d[\"cases\"]\n        else:\n            return {\"NO_CASE\": {}}\n\n    @staticmethod\n    def _format_dict_scenes(d: scenery.manifest.RawManifestDict) -&gt; list[dict]:\n        has_one = \"scene\" in d\n        has_many = \"scenes\" in d\n        if has_one:\n            return [d[\"scene\"]]\n        elif has_many:\n            return d[\"scenes\"]\n        else:\n            raise ValueError\n\n    @staticmethod\n    def parse_dict(d: dict) -&gt; scenery.manifest.Manifest:\n        \"\"\"\n        Parse a manifest dictionary into a Manifest object.\n\n        This method validates the dictionary, formats it, and then parses it into a Manifest object.\n\n        Args:\n            d (dict): The manifest dictionary to parse.\n\n        Returns:\n            scenery.manifest.Manifest: A Manifest object created from the input dictionary.\n        \"\"\"\n        ManifestParser.validate_dict(d)\n        formatted_d = ManifestParser.format_dict(cast(scenery.manifest.RawManifestDict, d))\n        return scenery.manifest.Manifest.from_formatted_dict(formatted_d)\n\n    ##########\n    # YAML\n    ##########\n\n    @staticmethod\n    def validate_yaml(obj: Any) -&gt; None:\n        \"\"\"\n        Validate the structure of a YAML-loaded manifest.\n\n        This method checks if the YAML content is a dictionary and if it contains only expected keys.\n\n        Args:\n            obj (Any): The YAML content to validate.\n\n        Raises:\n            TypeError: If the YAML content is not a dictionary.\n            ValueError: If the YAML content contains unexpected keys.\n        \"\"\"\n        if not isinstance(obj, dict):\n            raise TypeError(f\"Manifest need to be a dict not a '{type(obj)}'\")\n\n        if not all(\n            key in scenery.manifest.RawManifestDict.__annotations__.keys() for key in obj.keys()\n        ):\n            raise ValueError(\n                f\"Invalid key(s) in {obj.keys()} ({obj.get('manifest_origin', 'No origin found.')})\"\n            )\n\n    @staticmethod\n    def _yaml_constructor_case(\n        loader: yaml.SafeLoader, node: yaml.nodes.Node\n    ) -&gt; scenery.manifest.Substituable:\n        if isinstance(node, yaml.nodes.ScalarNode):\n            return scenery.manifest.Substituable(loader.construct_scalar(node))\n        else:\n            raise ConstructorError\n\n    @staticmethod\n    def _yaml_constructor_common_item(loader: yaml.SafeLoader, node: yaml.nodes.Node) -&gt; dict:\n        if isinstance(node, yaml.nodes.ScalarNode):\n            return ManifestParser.common_items[loader.construct_scalar(node)]\n        if isinstance(node, yaml.nodes.MappingNode):\n            d = loader.construct_mapping(node)\n            case = ManifestParser.common_items[d[\"ID\"]] | {\n                key: value for key, value in d.items() if key != \"ID\"\n            }\n            return case\n        else:\n            raise ConstructorError\n\n    @staticmethod\n    # def read_manifest_yaml(filename: str) -&gt; Any:\n    def read_manifest_yaml(stream: str | io.TextIOWrapper) -&gt; Any:\n        \"\"\"\n        Read a YAML manifest stream with custom tags.\n\n        This method uses a custom YAML loader to handle special tags like !case and !common-item.\n\n        Args:\n            stream(str | StringIO): The stream of the YAML manifest to read.\n\n        Returns:\n            dict: The parsed content of the YAML file.\n        \"\"\"\n        # NOTE: inspired by https://matthewpburruss.com/post/yaml/\n\n        # Add constructor\n        Loader = yaml.FullLoader\n        Loader.add_constructor(\"!case\", ManifestParser._yaml_constructor_case)\n        Loader.add_constructor(\"!common-item\", ManifestParser._yaml_constructor_common_item)\n\n        # with open(filename) as f:\n        #     content = yaml.load(f, Loader)\n\n        content = yaml.load(stream, Loader)\n        ManifestParser.validate_yaml(content)\n        return content\n\n\n    @staticmethod\n    def parse_yaml_from_file(filename: str) -&gt; scenery.manifest.Manifest:\n        \"\"\"\n        Parse a YAML manifest file into a Manifest object.\n\n        This method reads the YAML file, validates its content, and then parses it into a Manifest object.\n\n        Args:\n            filename (str): The filename of the YAML manifest to parse.\n\n        Returns:\n            scenery.manifest.Manifest: A Manifest object created from the YAML file.\n        \"\"\"\n        with open(filename) as f:\n            d = ManifestParser.read_manifest_yaml(f)\n        d[\"manifest_origin\"] = d.get(\"manifest_origin\", filename)\n        return ManifestParser.parse_dict(d)\n</code></pre>"},{"location":"api/#scenery.manifest_parser.ManifestParser.format_dict","title":"<code>format_dict(d)</code>  <code>staticmethod</code>","text":"<p>Reformat the manifest dictionary to ensure it has all expected keys and provide default values if needed.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The original manifest dictionary.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>ManifestDict</code> <p>A formatted dictionary with all expected keys.</p> Source code in <code>scenery/manifest_parser.py</code> <pre><code>@staticmethod\ndef format_dict(d: scenery.manifest.RawManifestDict) -&gt; scenery.manifest.ManifestDict:\n    \"\"\"\n    Reformat the manifest dictionary to ensure it has all expected keys and provide default values if needed.\n\n    Args:\n        d (dict): The original manifest dictionary.\n\n    Returns:\n        dict: A formatted dictionary with all expected keys.\n    \"\"\"\n    return {\n        \"set_up_class\": d.get(\"set_up_class\", []),\n        \"set_up\": d.get(\"set_up\", []),\n        \"scenes\": ManifestParser._format_dict_scenes(d),\n        \"cases\": ManifestParser._format_dict_cases(d),\n        \"manifest_origin\": d[\"manifest_origin\"],\n        \"ttype\": d.get(\"ttype\")\n    }\n</code></pre>"},{"location":"api/#scenery.manifest_parser.ManifestParser.parse_dict","title":"<code>parse_dict(d)</code>  <code>staticmethod</code>","text":"<p>Parse a manifest dictionary into a Manifest object.</p> <p>This method validates the dictionary, formats it, and then parses it into a Manifest object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The manifest dictionary to parse.</p> required <p>Returns:</p> Type Description <code>Manifest</code> <p>scenery.manifest.Manifest: A Manifest object created from the input dictionary.</p> Source code in <code>scenery/manifest_parser.py</code> <pre><code>@staticmethod\ndef parse_dict(d: dict) -&gt; scenery.manifest.Manifest:\n    \"\"\"\n    Parse a manifest dictionary into a Manifest object.\n\n    This method validates the dictionary, formats it, and then parses it into a Manifest object.\n\n    Args:\n        d (dict): The manifest dictionary to parse.\n\n    Returns:\n        scenery.manifest.Manifest: A Manifest object created from the input dictionary.\n    \"\"\"\n    ManifestParser.validate_dict(d)\n    formatted_d = ManifestParser.format_dict(cast(scenery.manifest.RawManifestDict, d))\n    return scenery.manifest.Manifest.from_formatted_dict(formatted_d)\n</code></pre>"},{"location":"api/#scenery.manifest_parser.ManifestParser.parse_yaml_from_file","title":"<code>parse_yaml_from_file(filename)</code>  <code>staticmethod</code>","text":"<p>Parse a YAML manifest file into a Manifest object.</p> <p>This method reads the YAML file, validates its content, and then parses it into a Manifest object.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the YAML manifest to parse.</p> required <p>Returns:</p> Type Description <code>Manifest</code> <p>scenery.manifest.Manifest: A Manifest object created from the YAML file.</p> Source code in <code>scenery/manifest_parser.py</code> <pre><code>@staticmethod\ndef parse_yaml_from_file(filename: str) -&gt; scenery.manifest.Manifest:\n    \"\"\"\n    Parse a YAML manifest file into a Manifest object.\n\n    This method reads the YAML file, validates its content, and then parses it into a Manifest object.\n\n    Args:\n        filename (str): The filename of the YAML manifest to parse.\n\n    Returns:\n        scenery.manifest.Manifest: A Manifest object created from the YAML file.\n    \"\"\"\n    with open(filename) as f:\n        d = ManifestParser.read_manifest_yaml(f)\n    d[\"manifest_origin\"] = d.get(\"manifest_origin\", filename)\n    return ManifestParser.parse_dict(d)\n</code></pre>"},{"location":"api/#scenery.manifest_parser.ManifestParser.read_manifest_yaml","title":"<code>read_manifest_yaml(stream)</code>  <code>staticmethod</code>","text":"<p>Read a YAML manifest stream with custom tags.</p> <p>This method uses a custom YAML loader to handle special tags like !case and !common-item.</p> <p>Parameters:</p> Name Type Description Default <code>stream(str</code> <code>| StringIO</code> <p>The stream of the YAML manifest to read.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Any</code> <p>The parsed content of the YAML file.</p> Source code in <code>scenery/manifest_parser.py</code> <pre><code>@staticmethod\n# def read_manifest_yaml(filename: str) -&gt; Any:\ndef read_manifest_yaml(stream: str | io.TextIOWrapper) -&gt; Any:\n    \"\"\"\n    Read a YAML manifest stream with custom tags.\n\n    This method uses a custom YAML loader to handle special tags like !case and !common-item.\n\n    Args:\n        stream(str | StringIO): The stream of the YAML manifest to read.\n\n    Returns:\n        dict: The parsed content of the YAML file.\n    \"\"\"\n    # NOTE: inspired by https://matthewpburruss.com/post/yaml/\n\n    # Add constructor\n    Loader = yaml.FullLoader\n    Loader.add_constructor(\"!case\", ManifestParser._yaml_constructor_case)\n    Loader.add_constructor(\"!common-item\", ManifestParser._yaml_constructor_common_item)\n\n    # with open(filename) as f:\n    #     content = yaml.load(f, Loader)\n\n    content = yaml.load(stream, Loader)\n    ManifestParser.validate_yaml(content)\n    return content\n</code></pre>"},{"location":"api/#scenery.manifest_parser.ManifestParser.validate_dict","title":"<code>validate_dict(d)</code>  <code>staticmethod</code>","text":"<p>Validate the top-level keys of a manifest dictionary.</p> <p>This method checks if only valid keys are present at the top level and ensures that either singular or plural forms of 'case' and 'scene' are provided, but not both.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The manifest dictionary to validate.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If invalid keys are present or if the case/scene keys are not correctly specified.</p> Source code in <code>scenery/manifest_parser.py</code> <pre><code>@staticmethod\ndef validate_dict(d: dict) -&gt; None:  # scenery.manifest.RawManifestDict\n    \"\"\"\n    Validate the top-level keys of a manifest dictionary.\n\n    This method checks if only valid keys are present at the top level and ensures\n    that either singular or plural forms of 'case' and 'scene' are provided, but not both.\n\n    Args:\n        d (dict): The manifest dictionary to validate.\n\n    Raises:\n        ValueError: If invalid keys are present or if the case/scene keys are not correctly specified.\n    \"\"\"\n    if not all(\n        key in scenery.manifest.RawManifestDict.__annotations__.keys() for key in d.keys()\n    ):\n        raise ValueError(\n            f\"Invalid key(s) in {d.keys()} ({d.get('manifest_origin', 'No origin found.')})\"\n        )\n\n    for key in [\"case\", \"scene\"]:\n        has_one = key in d\n        has_many = f\"{key}s\" in d\n\n        if has_one and has_many:\n            raise ValueError(\n                f\"Both `{key}` and `{key}s` keys are present at top level.\",\n            )\n\n        if key == \"scene\" and not (has_one or has_many):\n            raise ValueError(\n                f\"Neither `{key}` and `{key}s` keys are present at top level.\",\n            )\n</code></pre>"},{"location":"api/#scenery.manifest_parser.ManifestParser.validate_yaml","title":"<code>validate_yaml(obj)</code>  <code>staticmethod</code>","text":"<p>Validate the structure of a YAML-loaded manifest.</p> <p>This method checks if the YAML content is a dictionary and if it contains only expected keys.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The YAML content to validate.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the YAML content is not a dictionary.</p> <code>ValueError</code> <p>If the YAML content contains unexpected keys.</p> Source code in <code>scenery/manifest_parser.py</code> <pre><code>@staticmethod\ndef validate_yaml(obj: Any) -&gt; None:\n    \"\"\"\n    Validate the structure of a YAML-loaded manifest.\n\n    This method checks if the YAML content is a dictionary and if it contains only expected keys.\n\n    Args:\n        obj (Any): The YAML content to validate.\n\n    Raises:\n        TypeError: If the YAML content is not a dictionary.\n        ValueError: If the YAML content contains unexpected keys.\n    \"\"\"\n    if not isinstance(obj, dict):\n        raise TypeError(f\"Manifest need to be a dict not a '{type(obj)}'\")\n\n    if not all(\n        key in scenery.manifest.RawManifestDict.__annotations__.keys() for key in obj.keys()\n    ):\n        raise ValueError(\n            f\"Invalid key(s) in {obj.keys()} ({obj.get('manifest_origin', 'No origin found.')})\"\n        )\n</code></pre>"},{"location":"api/#manifest","title":"Manifest","text":"<p>Represent all data conveied by the manifest.</p>"},{"location":"api/#scenery.manifest.Case","title":"<code>Case</code>  <code>dataclass</code>","text":"<p>Store a collection of items representing a test case.</p> <p>Attributes:</p> Name Type Description <code>_id</code> <code>str</code> <p>The identifier for this case.</p> <code>items</code> <code>dict[str, Item]</code> <p>A dictionary of items in this case, indexed by item ID.</p> <p>Methods:</p> Name Description <code>__getitem__</code> <p>Retrieve an item from the case by its ID.</p> Class Methods <p>from_id_and_dict(case_id: str, items: dict[str, dict]) -&gt; Case:     Create a Case instance from a case ID and a dictionary of items.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass(frozen=True)\nclass Case:\n    \"\"\"Store a collection of items representing a test case.\n\n    Attributes:\n        _id (str): The identifier for this case.\n        items (dict[str, Item]): A dictionary of items in this case, indexed by item ID.\n\n    Methods:\n        __getitem__(item_id): Retrieve an item from the case by its ID.\n\n    Class Methods:\n        from_id_and_dict(case_id: str, items: dict[str, dict]) -&gt; Case:\n            Create a Case instance from a case ID and a dictionary of items.\n    \"\"\"\n\n    _id: str\n    items: dict[str, Item]\n\n    def __getitem__(self, item_id: str) -&gt; Item:\n        return self.items[item_id]\n\n    @classmethod\n    def from_id_and_dict(cls, case_id: str, items_dict: dict[str, dict[str, Any]]) -&gt; \"Case\":\n        \"\"\"Return a case from an id and a dict.\"\"\"\n        items = {item_id: Item(item_id, item_dict) for item_id, item_dict in items_dict.items()}\n        return cls(case_id, items)\n</code></pre>"},{"location":"api/#scenery.manifest.Case.from_id_and_dict","title":"<code>from_id_and_dict(case_id, items_dict)</code>  <code>classmethod</code>","text":"<p>Return a case from an id and a dict.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@classmethod\ndef from_id_and_dict(cls, case_id: str, items_dict: dict[str, dict[str, Any]]) -&gt; \"Case\":\n    \"\"\"Return a case from an id and a dict.\"\"\"\n    items = {item_id: Item(item_id, item_dict) for item_id, item_dict in items_dict.items()}\n    return cls(case_id, items)\n</code></pre>"},{"location":"api/#scenery.manifest.Check","title":"<code>Check</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Directive</code></p> <p>Store a given check to perform (after the subsitution).</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass\nclass Check(Directive):\n    \"\"\"Store a given check to perform (after the subsitution).\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Format self.args.\"\"\"\n        match self.instruction, self.args:\n            case DirectiveCommand.STATUS_CODE, int(n):\n                self.args = http.HTTPStatus(n)\n            case DirectiveCommand.DOM_ELEMENT, dict(d):\n                self.args = {DomArgument(key): value for key, value in d.items()}\n                if attribute := self.args.get(DomArgument.ATTRIBUTE):\n                    if value:= attribute.get(\"value\"):\n                        self.args[DomArgument.ATTRIBUTE][\"value\"] = (\n                            self._format_dom_element_attribute_value(value)\n                        )\n            case DirectiveCommand.REDIRECT_URL, str(_):\n                pass\n            case DirectiveCommand.COUNT_INSTANCES, {\"model\": ModelBase(), \"n\": int(n)}:\n                # NOTE mad: Validate model is registered\n                app_config = django_apps.get_app_config(os.environ[\"SCENERY_TESTED_APP_NAME\"])\n                app_config.get_model(self.args[\"model\"].__name__)\n            case DirectiveCommand.JS_STRINGIFY, _:\n                # TODO mad: js_stringify\n                pass\n            case DirectiveCommand.JSON, {\"key\": str(_), \"value\": _} :\n                pass\n            case DirectiveCommand.FIELD_OF_INSTANCE, {\"find\":{\"model\": ModelBase()}, \"field\": str(_), \"value\": _}:\n                # NOTE mad: Validate model is registered\n                app_config = django_apps.get_app_config(os.environ[\"SCENERY_TESTED_APP_NAME\"])\n                app_config.get_model(self.args[\"find\"][\"model\"].__name__)\n\n            case _:\n                raise ValueError(\n                    f\"Cannot interpret '{self.instruction}:({self.args})' as Check\"\n                )\n\n    @staticmethod\n    def _format_dom_element_attribute_value(value: str | int | list[str]) -&gt; list[str] | str:\n        if isinstance(value, (str, list)):\n            return value\n        elif isinstance(value, int):\n            return str(value)\n        else:\n            raise TypeError(\n                f\"attribute value can only be `str` or `list[str]` not {value} ('{type(value)}')\"\n            )\n</code></pre>"},{"location":"api/#scenery.manifest.Check.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Format self.args.</p> Source code in <code>scenery/manifest.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Format self.args.\"\"\"\n    match self.instruction, self.args:\n        case DirectiveCommand.STATUS_CODE, int(n):\n            self.args = http.HTTPStatus(n)\n        case DirectiveCommand.DOM_ELEMENT, dict(d):\n            self.args = {DomArgument(key): value for key, value in d.items()}\n            if attribute := self.args.get(DomArgument.ATTRIBUTE):\n                if value:= attribute.get(\"value\"):\n                    self.args[DomArgument.ATTRIBUTE][\"value\"] = (\n                        self._format_dom_element_attribute_value(value)\n                    )\n        case DirectiveCommand.REDIRECT_URL, str(_):\n            pass\n        case DirectiveCommand.COUNT_INSTANCES, {\"model\": ModelBase(), \"n\": int(n)}:\n            # NOTE mad: Validate model is registered\n            app_config = django_apps.get_app_config(os.environ[\"SCENERY_TESTED_APP_NAME\"])\n            app_config.get_model(self.args[\"model\"].__name__)\n        case DirectiveCommand.JS_STRINGIFY, _:\n            # TODO mad: js_stringify\n            pass\n        case DirectiveCommand.JSON, {\"key\": str(_), \"value\": _} :\n            pass\n        case DirectiveCommand.FIELD_OF_INSTANCE, {\"find\":{\"model\": ModelBase()}, \"field\": str(_), \"value\": _}:\n            # NOTE mad: Validate model is registered\n            app_config = django_apps.get_app_config(os.environ[\"SCENERY_TESTED_APP_NAME\"])\n            app_config.get_model(self.args[\"find\"][\"model\"].__name__)\n\n        case _:\n            raise ValueError(\n                f\"Cannot interpret '{self.instruction}:({self.args})' as Check\"\n            )\n</code></pre>"},{"location":"api/#scenery.manifest.Directive","title":"<code>Directive</code>  <code>dataclass</code>","text":"<p>Store a given check to perform, before the substitution (this is part of a Scene, not a Take).</p> <p>This class represents a directive (check) to be performed on an HTTP response, before case-specific substitutions have been made.</p> <p>Attributes:</p> Name Type Description <code>instruction</code> <code>DirectiveCommand</code> <p>The type of check to perform.</p> <code>args</code> <code>Any</code> <p>The arguments for the check.</p> Class Methods <p>from_dict(directive_dict: dict) -&gt; Directive:     Create an Directive instance from a dictionary.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass\nclass Directive:\n    \"\"\"Store a given check to perform, before the substitution (this is part of a Scene, not a Take).\n\n    This class represents a directive (check) to be performed on an HTTP response,\n    before case-specific substitutions have been made.\n\n    Attributes:\n        instruction (DirectiveCommand): The type of check to perform.\n        args (Any): The arguments for the check.\n\n    Class Methods:\n        from_dict(directive_dict: dict) -&gt; Directive:\n            Create an Directive instance from a dictionary.\n    \"\"\"\n\n    instruction: DirectiveCommand\n    args: Any\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Format self.args.\"\"\"\n        match self.instruction, self.args:\n            case DirectiveCommand.STATUS_CODE, int(n):\n                self.args = http.HTTPStatus(n)\n                # NOTE: Workaround if we want the class to be frozen\n                # object.__setattr__(self, \"args\", HTTPStatus(n))\n                pass\n            case DirectiveCommand.STATUS_CODE, Substituable():\n                pass\n            case DirectiveCommand.DOM_ELEMENT, dict(d):\n                self.args = {DomArgument(key): value for key, value in d.items()}\n                # Check if there is and only one locator\n                locators = [\n                    self.args.get(key, None) for key in (DomArgument.FIND_ALL, DomArgument.FIND)\n                ]\n                if not any(locators):\n                    raise ValueError(\"Neither `find_all` or `find` provided to check DOM element\")\n                else:\n                    locators = list(filter(None, locators))\n                    if len(locators) &gt; 1:\n                        raise ValueError(\"More than one locator provided\")\n\n            case DirectiveCommand.DOM_ELEMENT, Substituable():\n                pass\n            case DirectiveCommand.REDIRECT_URL, str(s):\n                pass\n            case DirectiveCommand.REDIRECT_URL, Substituable():\n                pass\n            case DirectiveCommand.COUNT_INSTANCES, {\"model\": str(s), \"n\": int(n)}:\n                # if os.environ.get(\"DJANGO_SETTINGS_MODULE\"):\n                app_config = django_apps.get_app_config(os.environ[\"SCENERY_TESTED_APP_NAME\"])\n                self.args[\"model\"] = app_config.get_model(s)\n            case DirectiveCommand.COUNT_INSTANCES, Substituable():\n                pass\n            case DirectiveCommand.JSON, {\"key\": str(s), \"value\": _}: # \n                pass\n            case DirectiveCommand.FIELD_OF_INSTANCE, {\"find\": {\"model\": str(model)}, \"field\": str(s), \"value\": _}: # \n                # if os.environ.get(\"DJANGO_SETTINGS_MODULE\"):\n                app_config = django_apps.get_app_config(os.environ[\"SCENERY_TESTED_APP_NAME\"])\n                self.args[\"find\"][\"model\"] = app_config.get_model(model)\n            case _:\n                raise ValueError(\n                    f\"Cannot interpret '{self.instruction}:({self.args})' as Directive\"\n                )\n\n    @classmethod\n    def from_dict(cls, directive_dict: dict) -&gt; \"Directive\":\n        \"\"\"Return the Directive based on the provided dict.\"\"\"\n        instruction, args = SingleKeyDict(directive_dict).as_tuple()\n        return cls(DirectiveCommand(instruction), args)\n</code></pre>"},{"location":"api/#scenery.manifest.Directive.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Format self.args.</p> Source code in <code>scenery/manifest.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Format self.args.\"\"\"\n    match self.instruction, self.args:\n        case DirectiveCommand.STATUS_CODE, int(n):\n            self.args = http.HTTPStatus(n)\n            # NOTE: Workaround if we want the class to be frozen\n            # object.__setattr__(self, \"args\", HTTPStatus(n))\n            pass\n        case DirectiveCommand.STATUS_CODE, Substituable():\n            pass\n        case DirectiveCommand.DOM_ELEMENT, dict(d):\n            self.args = {DomArgument(key): value for key, value in d.items()}\n            # Check if there is and only one locator\n            locators = [\n                self.args.get(key, None) for key in (DomArgument.FIND_ALL, DomArgument.FIND)\n            ]\n            if not any(locators):\n                raise ValueError(\"Neither `find_all` or `find` provided to check DOM element\")\n            else:\n                locators = list(filter(None, locators))\n                if len(locators) &gt; 1:\n                    raise ValueError(\"More than one locator provided\")\n\n        case DirectiveCommand.DOM_ELEMENT, Substituable():\n            pass\n        case DirectiveCommand.REDIRECT_URL, str(s):\n            pass\n        case DirectiveCommand.REDIRECT_URL, Substituable():\n            pass\n        case DirectiveCommand.COUNT_INSTANCES, {\"model\": str(s), \"n\": int(n)}:\n            # if os.environ.get(\"DJANGO_SETTINGS_MODULE\"):\n            app_config = django_apps.get_app_config(os.environ[\"SCENERY_TESTED_APP_NAME\"])\n            self.args[\"model\"] = app_config.get_model(s)\n        case DirectiveCommand.COUNT_INSTANCES, Substituable():\n            pass\n        case DirectiveCommand.JSON, {\"key\": str(s), \"value\": _}: # \n            pass\n        case DirectiveCommand.FIELD_OF_INSTANCE, {\"find\": {\"model\": str(model)}, \"field\": str(s), \"value\": _}: # \n            # if os.environ.get(\"DJANGO_SETTINGS_MODULE\"):\n            app_config = django_apps.get_app_config(os.environ[\"SCENERY_TESTED_APP_NAME\"])\n            self.args[\"find\"][\"model\"] = app_config.get_model(model)\n        case _:\n            raise ValueError(\n                f\"Cannot interpret '{self.instruction}:({self.args})' as Directive\"\n            )\n</code></pre>"},{"location":"api/#scenery.manifest.Directive.from_dict","title":"<code>from_dict(directive_dict)</code>  <code>classmethod</code>","text":"<p>Return the Directive based on the provided dict.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@classmethod\ndef from_dict(cls, directive_dict: dict) -&gt; \"Directive\":\n    \"\"\"Return the Directive based on the provided dict.\"\"\"\n    instruction, args = SingleKeyDict(directive_dict).as_tuple()\n    return cls(DirectiveCommand(instruction), args)\n</code></pre>"},{"location":"api/#scenery.manifest.DirectiveCommand","title":"<code>DirectiveCommand</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Values allowed for Manifest[\"checks\"].</p> Source code in <code>scenery/manifest.py</code> <pre><code>class DirectiveCommand(enum.Enum):\n    \"\"\"Values allowed for Manifest[\"checks\"].\"\"\"\n\n    STATUS_CODE = \"status_code\"\n    REDIRECT_URL = \"redirect_url\"\n    COUNT_INSTANCES = \"count_instances\"\n    DOM_ELEMENT = \"dom_element\"\n    FIELD_OF_INSTANCE = \"field_of_instance\"\n    # JS_VARIABLE = \"js_variable\"\n    JS_STRINGIFY = \"js_stringify\"\n    JSON = \"inspect_json\"\n</code></pre>"},{"location":"api/#scenery.manifest.DomArgument","title":"<code>DomArgument</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Values allowed for Manifest\"checks.</p> Source code in <code>scenery/manifest.py</code> <pre><code>class DomArgument(enum.Enum):\n    \"\"\"Values allowed for Manifest[\"checks][\"dom_element\"].\"\"\"\n\n    FIND = \"find\"\n    FIND_ALL = \"find_all\"\n    COUNT = \"count\"\n    SCOPE = \"scope\"\n    TEXT = \"text\"\n    ATTRIBUTE = \"attribute\"\n</code></pre>"},{"location":"api/#scenery.manifest.Item","title":"<code>Item</code>  <code>dataclass</code>","text":"<p>Store potential information that will be used to build the HTTP Request.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass(frozen=True)\nclass Item:\n    \"\"\"Store potential information that will be used to build the HTTP Request.\"\"\"\n\n    _id: str\n    _dict: dict[str, Any]\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self._dict[key]\n</code></pre>"},{"location":"api/#scenery.manifest.Manifest","title":"<code>Manifest</code>  <code>dataclass</code>","text":"<p>Store all the information to build/shoot all different <code>Takes</code>.</p> <p>This class represents a complete test manifest, including setup instructions, test cases, and scenes to be executed.</p> <p>Attributes:</p> Name Type Description <code>set_up_test_data</code> <code>list[SetUpInstruction]</code> <p>Instructions for setting up test data.</p> <code>set_up</code> <code>list[SetUpInstruction]</code> <p>Instructions for general test setup.</p> <code>scenes</code> <code>list[Scene]</code> <p>The scenes to be executed.</p> <code>cases</code> <code>dict[str, Case]</code> <p>The test cases, indexed by case ID.</p> <code>manifest_origin</code> <code>str</code> <p>The origin of the manifest file.</p> Class Methods <p>from_formatted_dict(d: dict) -&gt; Manifest:     Create a Manifest instance from a formatted dictionary.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass(frozen=True)\nclass Manifest:\n    \"\"\"Store all the information to build/shoot all different `Takes`.\n\n    This class represents a complete test manifest, including setup instructions,\n    test cases, and scenes to be executed.\n\n    Attributes:\n        set_up_test_data (list[SetUpInstruction]): Instructions for setting up test data.\n        set_up (list[SetUpInstruction]): Instructions for general test setup.\n        scenes (list[Scene]): The scenes to be executed.\n        cases (dict[str, Case]): The test cases, indexed by case ID.\n        manifest_origin (str): The origin of the manifest file.\n\n    Class Methods:\n        from_formatted_dict(d: dict) -&gt; Manifest:\n            Create a Manifest instance from a formatted dictionary.\n    \"\"\"\n\n    set_up_class: list[SetUpInstruction]\n    set_up: list[SetUpInstruction]\n    scenes: list[Scene]\n    cases: dict[str, Case]\n    manifest_origin: str\n    ttype: str | None\n\n    @classmethod\n    def from_formatted_dict(cls, d: ManifestDict) -&gt; \"Manifest\":\n        \"\"\"Return a manifest from a dict with expected keys.\"\"\"\n        return cls(\n            [\n                SetUpInstruction.from_object(instruction)\n                for instruction in d[\n                    \"set_up_class\"\n                ]  # d[ManifestFormattedDictKeys.set_up_test_data]\n            ],\n            [\n                SetUpInstruction.from_object(instruction)\n                for instruction in d[\"set_up\"]  # d[ManifestFormattedDictKeys.set_up]\n            ],\n            [\n                Scene.from_dict(scene) for scene in d[\"scenes\"]\n            ],  # d[ManifestFormattedDictKeys.scenes]],\n            {\n                case_id: Case.from_id_and_dict(case_id, case_dict)\n                for case_id, case_dict in d[\n                    \"cases\"\n                ].items()  # d[ManifestFormattedDictKeys.cases].items()\n            },\n            # d[ManifestFormattedDictKeys.manifest_origin],\n            d[\"manifest_origin\"],\n            d.get(\"ttype\")\n        )\n\n    def iter_on_takes(\n        self, \n        only_url: str | None, \n        only_case_id: str | None, \n        only_scene_pos: str | None\n    ) -&gt; typing.Iterable[typing.Tuple[str, int, \"Take\"]]:\n        for (case_id, case), (scene_pos, scene) in itertools.product(\n            self.cases.items(), enumerate(self.scenes)\n        ):\n            if only_case_id is not None and case_id != only_case_id:\n                continue\n            elif only_scene_pos is not None and str(scene_pos) != only_scene_pos:\n                continue\n            if only_url is not None and only_url != scene.url:\n                continue\n            take = scene.shoot(case)\n            yield case_id, scene_pos, take\n</code></pre>"},{"location":"api/#scenery.manifest.Manifest.from_formatted_dict","title":"<code>from_formatted_dict(d)</code>  <code>classmethod</code>","text":"<p>Return a manifest from a dict with expected keys.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@classmethod\ndef from_formatted_dict(cls, d: ManifestDict) -&gt; \"Manifest\":\n    \"\"\"Return a manifest from a dict with expected keys.\"\"\"\n    return cls(\n        [\n            SetUpInstruction.from_object(instruction)\n            for instruction in d[\n                \"set_up_class\"\n            ]  # d[ManifestFormattedDictKeys.set_up_test_data]\n        ],\n        [\n            SetUpInstruction.from_object(instruction)\n            for instruction in d[\"set_up\"]  # d[ManifestFormattedDictKeys.set_up]\n        ],\n        [\n            Scene.from_dict(scene) for scene in d[\"scenes\"]\n        ],  # d[ManifestFormattedDictKeys.scenes]],\n        {\n            case_id: Case.from_id_and_dict(case_id, case_dict)\n            for case_id, case_dict in d[\n                \"cases\"\n            ].items()  # d[ManifestFormattedDictKeys.cases].items()\n        },\n        # d[ManifestFormattedDictKeys.manifest_origin],\n        d[\"manifest_origin\"],\n        d.get(\"ttype\")\n    )\n</code></pre>"},{"location":"api/#scenery.manifest.ManifestDict","title":"<code>ManifestDict</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>The clean version of the dict parsed, ready to be transformed into a proper manifest.</p> Source code in <code>scenery/manifest.py</code> <pre><code>class ManifestDict(typing.TypedDict):\n    \"\"\"The clean version of the dict parsed, ready to be transformed into a proper manifest.\"\"\"\n\n    scenes: typing.List[dict]\n    cases: dict[str, dict]\n    manifest_origin: str\n    set_up_class: typing.Sequence[str | dict]\n    set_up: typing.Sequence[str | dict]\n    ttype: typing.Optional[str]\n</code></pre>"},{"location":"api/#scenery.manifest.RawManifestDict","title":"<code>RawManifestDict</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>The type of dict which can appear in the yamls.</p> Source code in <code>scenery/manifest.py</code> <pre><code>class RawManifestDict(typing.TypedDict, total=False):\n    \"\"\"The type of dict which can appear in the yamls.\"\"\"\n\n    set_up_class: typing.Sequence[dict]\n    set_up: typing.Sequence[dict]\n    case: dict\n    cases: dict[str, dict]\n    scene: dict\n    scenes: typing.List[dict]\n    manifest_origin: str\n    ttype: str\n</code></pre>"},{"location":"api/#scenery.manifest.Scene","title":"<code>Scene</code>  <code>dataclass</code>","text":"<p>Store all actions to perform, before the substitution of information from the <code>Cases</code>.</p> <p>This class represents an Scene, which includes the method, URL, and various parameters and checks to be performed.</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>HTTPMethod</code> <p>The HTTP method for this scene.</p> <code>url</code> <code>str</code> <p>The URL or URL pattern for this scene.</p> <code>directives</code> <code>list[Directive]</code> <p>The list of directives (checks) to perform.</p> <code>data</code> <code>dict[str, Any]</code> <p>The data to be sent with the request.</p> <code>query_parameters</code> <code>dict</code> <p>Query parameters for the URL.</p> <code>url_parameters</code> <code>dict</code> <p>URL parameters for reverse URL lookup.</p> <p>Methods:</p> Name Description <code>shoot</code> <p>Case) -&gt; Take: Create an Take instance by substituting case values into the scene.</p> Class Methods <p>from_dict(d: dict) -&gt; Scene:     Create an Scene instance from a dictionary. substitute_recursively(x, case: Case):     Recursively substitute values from a case into a data structure.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass\nclass Scene:\n    \"\"\"Store all actions to perform, before the substitution of information from the `Cases`.\n\n    This class represents an Scene, which includes the method, URL, and various\n    parameters and checks to be performed.\n\n    Attributes:\n        method (http.HTTPMethod): The HTTP method for this scene.\n        url (str): The URL or URL pattern for this scene.\n        directives (list[Directive]): The list of directives (checks) to perform.\n        data (dict[str, Any]): The data to be sent with the request.\n        query_parameters (dict): Query parameters for the URL.\n        url_parameters (dict): URL parameters for reverse URL lookup.\n\n    Methods:\n        shoot(case: Case) -&gt; Take:\n            Create an Take instance by substituting case values into the scene.\n\n    Class Methods:\n        from_dict(d: dict) -&gt; Scene:\n            Create an Scene instance from a dictionary.\n        substitute_recursively(x, case: Case):\n            Recursively substitute values from a case into a data structure.\n    \"\"\"\n\n    method: http.HTTPMethod\n    url: str\n    directives: list[Directive]\n    data: dict[str, Any] = field(default_factory=dict)\n    query_parameters: dict = field(default_factory=dict)\n    url_parameters: dict = field(default_factory=dict)\n    actions: typing.Optional[list[SetUpInstruction]] = field(default_factory=list)\n\n\n    def __post_init__(self) -&gt; None:\n        self.method = http.HTTPMethod(self.method)\n        # At this point we don't check url as we wait for subsitution\n        # potentially occuring through data/query_parameters/url_parameters\n\n    @classmethod\n    def from_dict(cls, d: dict) -&gt; \"Scene\":\n        \"\"\"Return a scene from a dict.\"\"\"\n        d[\"directives\"] = [Directive.from_dict(directive) for directive in d[\"directives\"]]\n        return cls(**d)\n\n    @classmethod\n    def substitute_recursively(cls, x: typing.Any, case: Case) -&gt; typing.Any:\n        \"\"\"Perform the substitution.\"\"\"\n        match x:\n            case int(_) | str(_):\n                return x\n            case ModelBase():\n                return x\n            case Substituable(_):\n                return x.shoot(case)\n            case Directive(instruction, args):\n                return Check(instruction, cls.substitute_recursively(args, case))\n            case dict(_):\n                return {key: cls.substitute_recursively(value, case) for key, value in x.items()}\n            case list(_):\n                return [cls.substitute_recursively(value, case) for value in x]\n            case _:\n                raise NotImplementedError(f\"Cannot substitute recursively '{x}' ('{type(x)}')\")\n\n    def shoot(self, case: Case) -&gt; \"Take\":\n        \"\"\"Return the Take resulting from the case applied to its scene.\"\"\"\n        return Take(\n            method=self.method,\n            url=self.url,\n            query_parameters=self.query_parameters,\n            data=self.substitute_recursively(self.data, case),\n            url_parameters=self.substitute_recursively(self.url_parameters, case),\n            checks=self.substitute_recursively(self.directives, case),\n        )\n</code></pre>"},{"location":"api/#scenery.manifest.Scene.from_dict","title":"<code>from_dict(d)</code>  <code>classmethod</code>","text":"<p>Return a scene from a dict.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict) -&gt; \"Scene\":\n    \"\"\"Return a scene from a dict.\"\"\"\n    d[\"directives\"] = [Directive.from_dict(directive) for directive in d[\"directives\"]]\n    return cls(**d)\n</code></pre>"},{"location":"api/#scenery.manifest.Scene.shoot","title":"<code>shoot(case)</code>","text":"<p>Return the Take resulting from the case applied to its scene.</p> Source code in <code>scenery/manifest.py</code> <pre><code>def shoot(self, case: Case) -&gt; \"Take\":\n    \"\"\"Return the Take resulting from the case applied to its scene.\"\"\"\n    return Take(\n        method=self.method,\n        url=self.url,\n        query_parameters=self.query_parameters,\n        data=self.substitute_recursively(self.data, case),\n        url_parameters=self.substitute_recursively(self.url_parameters, case),\n        checks=self.substitute_recursively(self.directives, case),\n    )\n</code></pre>"},{"location":"api/#scenery.manifest.Scene.substitute_recursively","title":"<code>substitute_recursively(x, case)</code>  <code>classmethod</code>","text":"<p>Perform the substitution.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@classmethod\ndef substitute_recursively(cls, x: typing.Any, case: Case) -&gt; typing.Any:\n    \"\"\"Perform the substitution.\"\"\"\n    match x:\n        case int(_) | str(_):\n            return x\n        case ModelBase():\n            return x\n        case Substituable(_):\n            return x.shoot(case)\n        case Directive(instruction, args):\n            return Check(instruction, cls.substitute_recursively(args, case))\n        case dict(_):\n            return {key: cls.substitute_recursively(value, case) for key, value in x.items()}\n        case list(_):\n            return [cls.substitute_recursively(value, case) for value in x]\n        case _:\n            raise NotImplementedError(f\"Cannot substitute recursively '{x}' ('{type(x)}')\")\n</code></pre>"},{"location":"api/#scenery.manifest.SetUpInstruction","title":"<code>SetUpInstruction</code>  <code>dataclass</code>","text":"<p>Store the command and potential arguments for setUpTestData and setUp.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass(frozen=True)\nclass SetUpInstruction:\n    \"\"\"Store the command and potential arguments for setUpTestData and setUp.\"\"\"\n\n    command: str\n    args: dict[str, Any] = field(default_factory=dict)\n\n    @classmethod\n    def from_object(cls, x: str | dict) -&gt; \"SetUpInstruction\":\n        \"\"\"Return an instruction from a string or a dict.\"\"\"\n        match x:\n            case str(s):\n                cmd_name, args = s, {}\n            case dict(d) if len(d) == 1:\n                cmd_name, args = SingleKeyDict(d).as_tuple()\n            case dict(d):\n                raise ValueError(\n                    f\"`SetUpInstruction` cannot be instantiated from dictionnary of length {len(x)}\\n{x}\"\n                )\n            case _:\n                raise TypeError(f\"`SetUpInstruction` cannot be instantiated from {type(x)}\")\n\n        return cls(cmd_name, args)\n</code></pre>"},{"location":"api/#scenery.manifest.SetUpInstruction.from_object","title":"<code>from_object(x)</code>  <code>classmethod</code>","text":"<p>Return an instruction from a string or a dict.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@classmethod\ndef from_object(cls, x: str | dict) -&gt; \"SetUpInstruction\":\n    \"\"\"Return an instruction from a string or a dict.\"\"\"\n    match x:\n        case str(s):\n            cmd_name, args = s, {}\n        case dict(d) if len(d) == 1:\n            cmd_name, args = SingleKeyDict(d).as_tuple()\n        case dict(d):\n            raise ValueError(\n                f\"`SetUpInstruction` cannot be instantiated from dictionnary of length {len(x)}\\n{x}\"\n            )\n        case _:\n            raise TypeError(f\"`SetUpInstruction` cannot be instantiated from {type(x)}\")\n\n    return cls(cmd_name, args)\n</code></pre>"},{"location":"api/#scenery.manifest.SingleKeyDict","title":"<code>SingleKeyDict</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[SingleKeyDictKey, SingleKeyDictKeyValue]</code></p> <p>A dataclass representing a dictionary with a single key-value pair.</p> <p>This class is useful for having a quick as_tuple representation of a dict {key:value} returned as (key, value).</p> <p>Attributes:</p> Name Type Description <code>_dict</code> <code>Dict[SingleKeyDictKey, SingleKeyDictKeyValue]</code> <p>The underlying dictionary.</p> <code>key</code> <code>SingleKeyDictKey</code> <p>The single key in the dictionary.</p> <code>value</code> <code>SingleKeyDictKeyValue</code> <p>The value associated with the single key.</p> <p>Methods:</p> Name Description <code>validate</code> <p>Ensures the dictionary has exactly one key-value pair.</p> <code>as_tuple</code> <p>Returns the key-value pair as a tuple.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dictionary does not contain exactly one key-value pair.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass\nclass SingleKeyDict(typing.Generic[SingleKeyDictKey, SingleKeyDictKeyValue]):\n    \"\"\"A dataclass representing a dictionary with a single key-value pair.\n\n    This class is useful for having a quick as_tuple representation of a dict {key:value}\n    returned as (key, value).\n\n    Attributes:\n        _dict (Dict[SingleKeyDictKey, SingleKeyDictKeyValue]): The underlying dictionary.\n        key (SingleKeyDictKey): The single key in the dictionary.\n        value (SingleKeyDictKeyValue): The value associated with the single key.\n\n    Methods:\n        validate(): Ensures the dictionary has exactly one key-value pair.\n        as_tuple(): Returns the key-value pair as a tuple.\n\n    Raises:\n        ValueError: If the dictionary does not contain exactly one key-value pair.\n    \"\"\"\n\n    _dict: typing.Dict[SingleKeyDictKey, SingleKeyDictKeyValue] = field()\n    key: SingleKeyDictKey = field(init=False)\n    value: SingleKeyDictKeyValue = field(init=False)\n\n    def __post_init__(self) -&gt; None:\n        self.validate()\n        self.key, self.value = next(iter(self._dict.items()))\n\n    def validate(self) -&gt; None:\n        \"\"\"Check the dictonary has indeed a single key.\"\"\"\n        if len(self._dict) != 1:\n            raise ValueError(\n                f\"SingleKeyDict should have length 1 not '{len(self._dict)}'\\n{self._dict}\"\n            )\n\n    def as_tuple(self) -&gt; tuple:\n        \"\"\"\ud83d\udd34 This should not be confused with built-in method datclasses.astuple.\"\"\"\n        return self.key, self.value\n</code></pre>"},{"location":"api/#scenery.manifest.SingleKeyDict.as_tuple","title":"<code>as_tuple()</code>","text":"<p>\ud83d\udd34 This should not be confused with built-in method datclasses.astuple.</p> Source code in <code>scenery/manifest.py</code> <pre><code>def as_tuple(self) -&gt; tuple:\n    \"\"\"\ud83d\udd34 This should not be confused with built-in method datclasses.astuple.\"\"\"\n    return self.key, self.value\n</code></pre>"},{"location":"api/#scenery.manifest.SingleKeyDict.validate","title":"<code>validate()</code>","text":"<p>Check the dictonary has indeed a single key.</p> Source code in <code>scenery/manifest.py</code> <pre><code>def validate(self) -&gt; None:\n    \"\"\"Check the dictonary has indeed a single key.\"\"\"\n    if len(self._dict) != 1:\n        raise ValueError(\n            f\"SingleKeyDict should have length 1 not '{len(self._dict)}'\\n{self._dict}\"\n        )\n</code></pre>"},{"location":"api/#scenery.manifest.Substituable","title":"<code>Substituable</code>  <code>dataclass</code>","text":"<p>Represent the field which need to be replace by some value coming from a given case.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass\nclass Substituable:\n    \"\"\"Represent the field which need to be replace by some value coming from a given case.\"\"\"\n\n    field_repr: str\n    regex_field = re.compile(r\"^(?P&lt;item_id&gt;[a-z_]+):?(?P&lt;field_name&gt;[a-z_]+)?$\")\n\n    def __post_init__(self) -&gt; None:\n        if not (re_match := re.match(self.regex_field, self.field_repr)):\n            raise ValueError(f\"Invalid field representation '{self.field_repr}'\")\n        else:\n            self.field_repr_match = re_match\n\n    def shoot(self, case: Case) -&gt; Any:\n        \"\"\"Return the corresponding case's value based on the field representation.\"\"\"\n        match self.field_repr_match.groups():\n            case item_id, None:\n                # There is only a reference to the item\n                # In this case , we pass all the variables with the dict\n                # return case[item_id][self.target]\n                return case[item_id]._dict\n            case item_id, field_name:\n                # There is only a reference to the item:field_name\n                # In this case, we pass only the corresponding value\n                # field_value = case[item_id][self.target][field_name]\n                field_value = case[item_id][field_name]\n                return field_value\n</code></pre>"},{"location":"api/#scenery.manifest.Substituable.shoot","title":"<code>shoot(case)</code>","text":"<p>Return the corresponding case's value based on the field representation.</p> Source code in <code>scenery/manifest.py</code> <pre><code>def shoot(self, case: Case) -&gt; Any:\n    \"\"\"Return the corresponding case's value based on the field representation.\"\"\"\n    match self.field_repr_match.groups():\n        case item_id, None:\n            # There is only a reference to the item\n            # In this case , we pass all the variables with the dict\n            # return case[item_id][self.target]\n            return case[item_id]._dict\n        case item_id, field_name:\n            # There is only a reference to the item:field_name\n            # In this case, we pass only the corresponding value\n            # field_value = case[item_id][self.target][field_name]\n            field_value = case[item_id][field_name]\n            return field_value\n</code></pre>"},{"location":"api/#scenery.manifest.Take","title":"<code>Take</code>  <code>dataclass</code>","text":"<p>Store all the information after the substitution from the <code>Cases</code> has been performed.</p> <p>This class represents a fully resolved HTTP request to be executed, including the method, URL, data, and checks to be performed.</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>HTTPMethod</code> <p>The HTTP method for this take.</p> <code>url</code> <code>str</code> <p>The fully resolved URL for this take.</p> <code>checks</code> <code>list[Check]</code> <p>The list of checks to perform on the response.</p> <code>data</code> <code>dict</code> <p>The data to be sent with the request.</p> <code>query_parameters</code> <code>dict</code> <p>Query parameters for the URL.</p> <code>url_parameters</code> <code>dict</code> <p>URL parameters used in URL resolution.</p> Notes <p>The <code>url</code> is expected to be either a valid URL or a registered viewname. If it's a viewname, it will be resolved using Django's <code>reverse</code> function.</p> Source code in <code>scenery/manifest.py</code> <pre><code>@dataclass\nclass Take:\n    \"\"\"Store all the information after the substitution from the `Cases` has been performed.\n\n    This class represents a fully resolved HTTP request to be executed, including\n    the method, URL, data, and checks to be performed.\n\n    Attributes:\n        method (http.HTTPMethod): The HTTP method for this take.\n        url (str): The fully resolved URL for this take.\n        checks (list[Check]): The list of checks to perform on the response.\n        data (dict): The data to be sent with the request.\n        query_parameters (dict): Query parameters for the URL.\n        url_parameters (dict): URL parameters used in URL resolution.\n\n    Notes:\n        The `url` is expected to be either a valid URL or a registered viewname.\n        If it's a viewname, it will be resolved using Django's `reverse` function.\n    \"\"\"\n\n    method: http.HTTPMethod\n    url: str\n    checks: list[Check]\n    data: dict\n    query_parameters: dict\n    url_parameters: dict\n\n    def __post_init__(self) -&gt; None:\n        self.method = http.HTTPMethod(self.method)\n\n        try:\n            # First we try if the url is a django viewname\n            url_name = self.url\n            self.url = reverse(self.url, kwargs=self.url_parameters)\n            self.url_name = url_name\n        except NoReverseMatch:\n            # Otherwise we check it is a valid url\n            parsed = urlparse(self.url)\n            if not (parsed.scheme and parsed.netloc):\n                raise ValueError(f\"'{self.url}' could not be reversed and is not a valid url\")\n\n        if self.query_parameters:\n            # NOTE mad: We use http.urlencode instead for compatibility\n            # https://stackoverflow.com/questions/4995279/including-a-querystring-in-a-django-core-urlresolvers-reverse-call\n            # https://gist.github.com/benbacardi/227f924ec1d9bedd242b\n            self.url += \"?\" + urlencode(self.query_parameters)\n</code></pre>"},{"location":"api/#method-builder","title":"Method builder","text":"<p>Building test methods dynamically based on manifest data.</p>"},{"location":"api/#scenery.method_builder.MethodBuilder","title":"<code>MethodBuilder</code>","text":"<p>A utility class for building test methods dynamically based on manifest data.</p> <p>This class provides static methods to create setup and test methods that can be added to Django test cases.</p> Source code in <code>scenery/method_builder.py</code> <pre><code>class MethodBuilder:\n    \"\"\"A utility class for building test methods dynamically based on manifest data.\n\n    This class provides static methods to create setup and test methods\n    that can be added to Django test cases.\n    \"\"\"\n\n    # NOTE mad: do not erase, but this is unused right now, but tested\n    @staticmethod\n    def build_setUpTestData(instructions: list[SetUpInstruction]) -&gt; classmethod:\n        \"\"\"Build a setUpTestData class method for a Django test case.\n\n        This method creates a class method that executes a series of setup\n        instructions before any test methods are run.\n\n        Args:\n            instructions (list[str]): A list of setup instructions to be executed.\n\n        Returns:\n            classmethod: A class method that can be added to a Django test case.\n        \"\"\"\n\n        def setUpTestData(testcase_cls: type[SceneryTestCase]) -&gt; None:\n            # TODO mad: not sure why this is needed\n            super(testcase_cls, testcase_cls).setUpTestData() # type: ignore[misc]\n\n            for instruction in instructions:\n                SetUpHandler.exec_set_up_instruction(testcase_cls, instruction)\n\n        return classmethod(setUpTestData)\n\n    @staticmethod\n    def build_setUpClass(\n        instructions: list[SetUpInstruction], driver: webdriver.Chrome | None, headless: bool = True\n    ) -&gt; classmethod:\n        \"\"\"\n        Build and return a class method for setup operations before any tests in a test case are run.\n\n        This method generates a setUpClass that:\n        - Sets up the test environment using Django's setup\n        - For FrontendDjangoTestCase subclasses, initializes a Selenium WebDriver\n        - Executes a list of setup instructions\n\n        Args:\n            instructions: A list of SetUpInstruction objects to be executed during setup\n            driver: An optional pre-configured Selenium Chrome WebDriver. If None, a new driver\n                will be created with the specified headless setting\n            headless: Boolean flag to run Chrome in headless mode (default: True)\n\n        Returns:\n            classmethod: A class method that handles test case setup operations\n        \"\"\"\n\n        def setUpClass(testcase_cls: type[SceneryTestCase]) -&gt; None:\n            logger.debug(setUpClass)\n            # TODO mad: not sure why this is needed\n            super(testcase_cls, testcase_cls).setUpClass()  # type: ignore[misc]\n\n            if issubclass(testcase_cls, (DjangoFrontendTestCase, RemoteFrontendTestCase)):\n                if driver is None:\n                    testcase_cls.driver = get_selenium_driver(headless)\n                else:\n                    testcase_cls.driver = driver\n\n                # chrome_options = Options()\n                # # NOTE mad: service does not play well with headless mode\n                # # service = Service(executable_path='/usr/bin/google-chrome')\n                # if headless:\n                #     chrome_options.add_argument(\"--headless=new\")     # NOTE mad: For newer Chrome versions\n                #     # chrome_options.add_argument(\"--headless\")           # NOTE mad: For older Chrome versions (Framework)\n                # testcase_cls.driver = webdriver.Chrome(options=chrome_options) #  service=service\n                # testcase_cls.driver.implicitly_wait(10)\n\n            for instruction in instructions:\n                SetUpHandler.exec_set_up_instruction(testcase_cls, instruction)\n\n        return classmethod(setUpClass)\n\n    @staticmethod\n    def build_tearDownClass() -&gt; classmethod:\n        \"\"\"\n        Build and return a class method for teardown operations after all tests in a test case have completed.\n\n        The generated tearDownClass method performs cleanup operations, specifically:\n        - For FrontendDjangoTestCase subclasses, it quits the Selenium WebDriver\n        - Calls the parent class's tearDownClass method\n\n        Returns:\n            classmethod: A class method that handles test case teardown operations\n        \"\"\"\n\n        def tearDownClass(testcase_cls: type[SceneryTestCase]) -&gt; None:\n            if issubclass(testcase_cls, DjangoFrontendTestCase):\n                testcase_cls.driver.quit()\n            # TODO mad: not sure why this is needed\n\n            super(testcase_cls, testcase_cls).tearDownClass()  # type: ignore[misc]\n\n        return classmethod(tearDownClass)\n\n\n    @staticmethod\n    def build_setUp(\n        instructions: list[SetUpInstruction]\n    ) -&gt; Callable[[SceneryTestCase], None]:\n        \"\"\"Build a setUp instance method for a Django test case.\n\n        This method creates an instance method that executes a series of setup\n        instructions before each test method is run.\n\n        Args:\n            instructions (list[str]): A list of setup instructions to be executed.\n\n        Returns:\n            function: An instance method that can be added to a Django test case.\n        \"\"\"\n        def setUp(testcase: SceneryTestCase) -&gt; None:\n\n            logger.debug(setUp)\n\n            # if isinstance(testcase, (RemoteBackendTestCase, LoadTestCase, DjangoFrontendTestCase)):\n            #     testcase.session = requests.Session()\n            if isinstance(testcase, (RemoteBackendTestCase, LoadTestCase,)):\n                testcase.session = requests.Session()\n                testcase.headers = {}\n            if isinstance(testcase, (RemoteBackendTestCase, RemoteFrontendTestCase, LoadTestCase)) :\n                testcase.base_url = os.environ[f\"SCENERY_{testcase.mode.upper()}_URL\"]\n            if isinstance(testcase, (DjangoFrontendTestCase,)) :\n                testcase.base_url = testcase.live_server_url\n            if isinstance(testcase, (LoadTestCase,)):\n                testcase.data = collections.defaultdict(list)\n\n\n            for instruction in instructions:\n                SetUpHandler.exec_set_up_instruction(testcase, instruction)\n\n        return setUp\n\n\n\n    @staticmethod\n    def build_test_integration(take: Take) -&gt; Callable:\n        \"\"\"Build a test method from an Take object.\n\n        This method creates a test function that sends an HTTP request\n        based on the take's specifications and executes a series of checks\n        on the response.\n\n        Args:\n            take (scenery.manifest.Take): An Take object specifying\n                the request to be made and the checks to be performed.\n\n        Returns:\n            function: A test method that can be added to a Django test case.\n        \"\"\"\n\n        # print(\"ON EST AL\")\n\n        def test(testcase: SceneryTestCase) -&gt; None:\n            logger.debug(test)\n\n            response: ResponseProtocol\n            if isinstance(testcase, DjangoBackendTestCase):\n                response = Checker.get_django_client_response(testcase, take)\n\n            elif isinstance(testcase, (DjangoFrontendTestCase, RemoteFrontendTestCase)):\n                response = Checker.get_selenium_response(testcase, take)\n\n            elif isinstance(testcase, RemoteBackendTestCase):\n                response = Checker.get_http_response(testcase, take)\n            else:\n                raise ValueError(f\"Unsupported test case type: {type(testcase)}\")\n\n\n            for i, check in enumerate(take.checks):\n\n                if isinstance(testcase, (DjangoFrontendTestCase, RemoteFrontendTestCase)) and check.instruction == DirectiveCommand.STATUS_CODE:\n                    continue\n\n                if isinstance(testcase, RemoteBackendTestCase) and check.instruction in [\n                        DirectiveCommand.COUNT_INSTANCES,\n                        DirectiveCommand.FIELD_OF_INSTANCE,\n                    ]:\n                        continue\n\n                with testcase.subTest(f\"directive {i}\"):\n                    Checker.exec_check(testcase, response, check)\n\n        return test\n\n    @staticmethod\n    def build_test_load(take: Take) -&gt; Callable:\n        def test(testcase: LoadTestCase) -&gt; None:\n\n            lock = threading.Lock()  # Thread synchronization\n\n            def make_request(testcase: LoadTestCase, session: requests.Session, take: Take, headers: dict[str, str]) -&gt; dict[str, int|float]:\n                \"\"\"Execute a single request and return response time and status\"\"\"\n\n                start_time = time.time()\n\n                if take.method == http.HTTPMethod.GET:\n                    response = session.get(\n                        testcase.base_url + take.url,\n                        data=take.data,\n                        headers=headers,\n                    )\n                elif take.method == http.HTTPMethod.POST:\n                    response = session.post(\n                        testcase.base_url + take.url,\n                        take.data,\n                        headers=headers,\n                    )\n                else:\n                    raise NotImplementedError(take.method)\n\n\n                elapsed_time = time.time() - start_time\n\n                # print(response.status_code)\n\n\n                if not (200 &lt;= response.status_code &lt; 300):\n                    logger.warning(f\"{response.status_code=}\")\n                    logger.debug(f\"{response.content.decode(\"utf8\")=}\")\n                return {\n                    'elapsed_time': elapsed_time,\n                    'status_code': response.status_code,\n                    'success': 200 &lt;= response.status_code &lt; 300\n                }\n\n            def _worker_task(testcase: LoadTestCase, take: Take, num_requests: int) -&gt; None:\n                \"\"\"Worker function executed by each thread\"\"\"\n                for _ in range(num_requests):\n                    result = make_request(testcase, testcase.session, take, testcase.headers)\n\n                    with lock:\n                        testcase.data[take.url].append(result)\n\n            # logger.info(f\"{ramp_up=}\")\n            logger.info(f\"{testcase.users=}\")\n            logger.info(f\"{testcase.requests_per_user=}\")\n            logger.info(f\"{take.url=}\")\n            logger.info(f\"{take.method=}\")\n            logger.info(f\"{take.data=}\")\n\n            # Create threads for each simulated user\n            threads = []\n            for i in range(testcase.users):\n                thread = threading.Thread(\n                    target=_worker_task,\n                    args=(testcase, take, testcase.requests_per_user),\n                )\n                threads.append(thread)\n\n                # Optional: implement ramp-up by staggering thread starts\n                thread.start()\n                # if ramp_up &gt; 0 and users &gt; 1:\n                #     time.sleep(ramp_up / (users - 1))\n\n            # Wait for all threads to complete\n            for thread in threads:\n                thread.join()\n\n\n        return test\n</code></pre>"},{"location":"api/#scenery.method_builder.MethodBuilder.build_setUp","title":"<code>build_setUp(instructions)</code>  <code>staticmethod</code>","text":"<p>Build a setUp instance method for a Django test case.</p> <p>This method creates an instance method that executes a series of setup instructions before each test method is run.</p> <p>Parameters:</p> Name Type Description Default <code>instructions</code> <code>list[str]</code> <p>A list of setup instructions to be executed.</p> required <p>Returns:</p> Name Type Description <code>function</code> <code>Callable[[SceneryTestCase], None]</code> <p>An instance method that can be added to a Django test case.</p> Source code in <code>scenery/method_builder.py</code> <pre><code>@staticmethod\ndef build_setUp(\n    instructions: list[SetUpInstruction]\n) -&gt; Callable[[SceneryTestCase], None]:\n    \"\"\"Build a setUp instance method for a Django test case.\n\n    This method creates an instance method that executes a series of setup\n    instructions before each test method is run.\n\n    Args:\n        instructions (list[str]): A list of setup instructions to be executed.\n\n    Returns:\n        function: An instance method that can be added to a Django test case.\n    \"\"\"\n    def setUp(testcase: SceneryTestCase) -&gt; None:\n\n        logger.debug(setUp)\n\n        # if isinstance(testcase, (RemoteBackendTestCase, LoadTestCase, DjangoFrontendTestCase)):\n        #     testcase.session = requests.Session()\n        if isinstance(testcase, (RemoteBackendTestCase, LoadTestCase,)):\n            testcase.session = requests.Session()\n            testcase.headers = {}\n        if isinstance(testcase, (RemoteBackendTestCase, RemoteFrontendTestCase, LoadTestCase)) :\n            testcase.base_url = os.environ[f\"SCENERY_{testcase.mode.upper()}_URL\"]\n        if isinstance(testcase, (DjangoFrontendTestCase,)) :\n            testcase.base_url = testcase.live_server_url\n        if isinstance(testcase, (LoadTestCase,)):\n            testcase.data = collections.defaultdict(list)\n\n\n        for instruction in instructions:\n            SetUpHandler.exec_set_up_instruction(testcase, instruction)\n\n    return setUp\n</code></pre>"},{"location":"api/#scenery.method_builder.MethodBuilder.build_setUpClass","title":"<code>build_setUpClass(instructions, driver, headless=True)</code>  <code>staticmethod</code>","text":"<p>Build and return a class method for setup operations before any tests in a test case are run.</p> <p>This method generates a setUpClass that: - Sets up the test environment using Django's setup - For FrontendDjangoTestCase subclasses, initializes a Selenium WebDriver - Executes a list of setup instructions</p> <p>Parameters:</p> Name Type Description Default <code>instructions</code> <code>list[SetUpInstruction]</code> <p>A list of SetUpInstruction objects to be executed during setup</p> required <code>driver</code> <code>Chrome | None</code> <p>An optional pre-configured Selenium Chrome WebDriver. If None, a new driver will be created with the specified headless setting</p> required <code>headless</code> <code>bool</code> <p>Boolean flag to run Chrome in headless mode (default: True)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>classmethod</code> <code>classmethod</code> <p>A class method that handles test case setup operations</p> Source code in <code>scenery/method_builder.py</code> <pre><code>@staticmethod\ndef build_setUpClass(\n    instructions: list[SetUpInstruction], driver: webdriver.Chrome | None, headless: bool = True\n) -&gt; classmethod:\n    \"\"\"\n    Build and return a class method for setup operations before any tests in a test case are run.\n\n    This method generates a setUpClass that:\n    - Sets up the test environment using Django's setup\n    - For FrontendDjangoTestCase subclasses, initializes a Selenium WebDriver\n    - Executes a list of setup instructions\n\n    Args:\n        instructions: A list of SetUpInstruction objects to be executed during setup\n        driver: An optional pre-configured Selenium Chrome WebDriver. If None, a new driver\n            will be created with the specified headless setting\n        headless: Boolean flag to run Chrome in headless mode (default: True)\n\n    Returns:\n        classmethod: A class method that handles test case setup operations\n    \"\"\"\n\n    def setUpClass(testcase_cls: type[SceneryTestCase]) -&gt; None:\n        logger.debug(setUpClass)\n        # TODO mad: not sure why this is needed\n        super(testcase_cls, testcase_cls).setUpClass()  # type: ignore[misc]\n\n        if issubclass(testcase_cls, (DjangoFrontendTestCase, RemoteFrontendTestCase)):\n            if driver is None:\n                testcase_cls.driver = get_selenium_driver(headless)\n            else:\n                testcase_cls.driver = driver\n\n            # chrome_options = Options()\n            # # NOTE mad: service does not play well with headless mode\n            # # service = Service(executable_path='/usr/bin/google-chrome')\n            # if headless:\n            #     chrome_options.add_argument(\"--headless=new\")     # NOTE mad: For newer Chrome versions\n            #     # chrome_options.add_argument(\"--headless\")           # NOTE mad: For older Chrome versions (Framework)\n            # testcase_cls.driver = webdriver.Chrome(options=chrome_options) #  service=service\n            # testcase_cls.driver.implicitly_wait(10)\n\n        for instruction in instructions:\n            SetUpHandler.exec_set_up_instruction(testcase_cls, instruction)\n\n    return classmethod(setUpClass)\n</code></pre>"},{"location":"api/#scenery.method_builder.MethodBuilder.build_setUpTestData","title":"<code>build_setUpTestData(instructions)</code>  <code>staticmethod</code>","text":"<p>Build a setUpTestData class method for a Django test case.</p> <p>This method creates a class method that executes a series of setup instructions before any test methods are run.</p> <p>Parameters:</p> Name Type Description Default <code>instructions</code> <code>list[str]</code> <p>A list of setup instructions to be executed.</p> required <p>Returns:</p> Name Type Description <code>classmethod</code> <code>classmethod</code> <p>A class method that can be added to a Django test case.</p> Source code in <code>scenery/method_builder.py</code> <pre><code>@staticmethod\ndef build_setUpTestData(instructions: list[SetUpInstruction]) -&gt; classmethod:\n    \"\"\"Build a setUpTestData class method for a Django test case.\n\n    This method creates a class method that executes a series of setup\n    instructions before any test methods are run.\n\n    Args:\n        instructions (list[str]): A list of setup instructions to be executed.\n\n    Returns:\n        classmethod: A class method that can be added to a Django test case.\n    \"\"\"\n\n    def setUpTestData(testcase_cls: type[SceneryTestCase]) -&gt; None:\n        # TODO mad: not sure why this is needed\n        super(testcase_cls, testcase_cls).setUpTestData() # type: ignore[misc]\n\n        for instruction in instructions:\n            SetUpHandler.exec_set_up_instruction(testcase_cls, instruction)\n\n    return classmethod(setUpTestData)\n</code></pre>"},{"location":"api/#scenery.method_builder.MethodBuilder.build_tearDownClass","title":"<code>build_tearDownClass()</code>  <code>staticmethod</code>","text":"<p>Build and return a class method for teardown operations after all tests in a test case have completed.</p> <p>The generated tearDownClass method performs cleanup operations, specifically: - For FrontendDjangoTestCase subclasses, it quits the Selenium WebDriver - Calls the parent class's tearDownClass method</p> <p>Returns:</p> Name Type Description <code>classmethod</code> <code>classmethod</code> <p>A class method that handles test case teardown operations</p> Source code in <code>scenery/method_builder.py</code> <pre><code>@staticmethod\ndef build_tearDownClass() -&gt; classmethod:\n    \"\"\"\n    Build and return a class method for teardown operations after all tests in a test case have completed.\n\n    The generated tearDownClass method performs cleanup operations, specifically:\n    - For FrontendDjangoTestCase subclasses, it quits the Selenium WebDriver\n    - Calls the parent class's tearDownClass method\n\n    Returns:\n        classmethod: A class method that handles test case teardown operations\n    \"\"\"\n\n    def tearDownClass(testcase_cls: type[SceneryTestCase]) -&gt; None:\n        if issubclass(testcase_cls, DjangoFrontendTestCase):\n            testcase_cls.driver.quit()\n        # TODO mad: not sure why this is needed\n\n        super(testcase_cls, testcase_cls).tearDownClass()  # type: ignore[misc]\n\n    return classmethod(tearDownClass)\n</code></pre>"},{"location":"api/#scenery.method_builder.MethodBuilder.build_test_integration","title":"<code>build_test_integration(take)</code>  <code>staticmethod</code>","text":"<p>Build a test method from an Take object.</p> <p>This method creates a test function that sends an HTTP request based on the take's specifications and executes a series of checks on the response.</p> <p>Parameters:</p> Name Type Description Default <code>take</code> <code>Take</code> <p>An Take object specifying the request to be made and the checks to be performed.</p> required <p>Returns:</p> Name Type Description <code>function</code> <code>Callable</code> <p>A test method that can be added to a Django test case.</p> Source code in <code>scenery/method_builder.py</code> <pre><code>@staticmethod\ndef build_test_integration(take: Take) -&gt; Callable:\n    \"\"\"Build a test method from an Take object.\n\n    This method creates a test function that sends an HTTP request\n    based on the take's specifications and executes a series of checks\n    on the response.\n\n    Args:\n        take (scenery.manifest.Take): An Take object specifying\n            the request to be made and the checks to be performed.\n\n    Returns:\n        function: A test method that can be added to a Django test case.\n    \"\"\"\n\n    # print(\"ON EST AL\")\n\n    def test(testcase: SceneryTestCase) -&gt; None:\n        logger.debug(test)\n\n        response: ResponseProtocol\n        if isinstance(testcase, DjangoBackendTestCase):\n            response = Checker.get_django_client_response(testcase, take)\n\n        elif isinstance(testcase, (DjangoFrontendTestCase, RemoteFrontendTestCase)):\n            response = Checker.get_selenium_response(testcase, take)\n\n        elif isinstance(testcase, RemoteBackendTestCase):\n            response = Checker.get_http_response(testcase, take)\n        else:\n            raise ValueError(f\"Unsupported test case type: {type(testcase)}\")\n\n\n        for i, check in enumerate(take.checks):\n\n            if isinstance(testcase, (DjangoFrontendTestCase, RemoteFrontendTestCase)) and check.instruction == DirectiveCommand.STATUS_CODE:\n                continue\n\n            if isinstance(testcase, RemoteBackendTestCase) and check.instruction in [\n                    DirectiveCommand.COUNT_INSTANCES,\n                    DirectiveCommand.FIELD_OF_INSTANCE,\n                ]:\n                    continue\n\n            with testcase.subTest(f\"directive {i}\"):\n                Checker.exec_check(testcase, response, check)\n\n    return test\n</code></pre>"},{"location":"api/#response-checker","title":"Response Checker","text":"<p>Perform assertions on HTTP response from the test client.</p>"},{"location":"api/#scenery.response_checker.Checker","title":"<code>Checker</code>","text":"<p>A utility class for performing HTTP requests and assertions on responses.</p> <p>This class provides static methods to execute HTTP requests and perform various checks on the responses, as specified in the test manifests.</p> Source code in <code>scenery/response_checker.py</code> <pre><code>class Checker:\n    \"\"\"A utility class for performing HTTP requests and assertions on responses.\n\n    This class provides static methods to execute HTTP requests and perform\n    various checks on the responses, as specified in the test manifests.\n    \"\"\"\n\n    # NOTE mad: the first functions take a Take \n    # as argument to retrieve the server respone\n    # The next function takes the response protocols\n    # and potentially other arguments to perform checks\n\n\n\n    # COLLECT RESPONSE\n    ##################\n\n    selenium_module = importlib.import_module(os.environ[\"SCENERY_POST_REQUESTS_INSTRUCTIONS_SELENIUM\"])\n\n\n    @staticmethod\n    def get_django_client_response(\n        testcase: DjangoBackendTestCase, take: Take\n    ) -&gt; django.http.HttpResponse:\n        \"\"\"Execute an HTTP request based on the given HttpTake object.\n\n        Args:\n            testcase (BackendDjangoTestCase): The Django testcase instance.\n            take (scenery.manifest.HttpTake): The HttpTake object specifying the request details.\n\n        Returns:\n            django.http.HttpResponse: The response from the HTTP request.\n\n        Raises:\n            NotImplementedError: If the HTTP method specified in the take is not implemented.\n        \"\"\"\n        logger.debug(Checker.get_django_client_response)\n        logger.debug(f\"{take.url=}\")\n        logger.debug(f\"{take.method=}\")\n        if take.data:\n            logger.debug(take.data)\n\n        if take.method == http.HTTPMethod.GET:\n            response = testcase.client.get(\n                take.url,\n                take.data,\n            )\n        elif take.method == http.HTTPMethod.POST:\n            response = testcase.client.post(\n                take.url,\n                take.data,\n            )\n        else:\n            raise NotImplementedError(take.method)\n\n        # FIXME mad: this one is a bit puzzling to me\n        # running mypy I get:\n        # Incompatible return value type (got \"_MonkeyPatchedWSGIResponse\", expected \"HttpResponse\")\n        return response # type: ignore[return-value]\n\n    @classmethod\n    def get_selenium_response(\n        cls, testcase: DjangoFrontendTestCase | RemoteFrontendTestCase, take: Take\n    ) -&gt; SeleniumResponse:\n        \"\"\"Create a SeleniumResponse by executing a request through Selenium WebDriver.\n\n        This function handles both GET and POST requests through Selenium. For POST requests,\n        it dynamically loads and executes request handlers from a configured Selenium module.\n\n        Args:\n            testcase (FrontendDjangoTestCase): The test case instance containing\n                the Selenium WebDriver and live server URL.\n            take (Take): The request specification containing method, URL, and data\n                for the request to be executed.\n\n        Returns:\n            SeleniumResponse: A wrapper containing the response from the Selenium-driven request.\n\n        Raises:\n            ImportError: If the SCENERY_POST_REQUESTS_INSTRUCTIONS_SELENIUM module cannot be loaded.\n            AttributeError: If a POST request handler method cannot be found in the Selenium module.\n\n        Notes:\n            - For POST requests, the handler method name is derived from the URL name by\n            replacing ':' with '_' and prefixing with 'post_'.\n            - The Selenium module path must be specified in the SCENERY_POST_REQUESTS_INSTRUCTIONS_SELENIUM\n            environment variable.\n        \"\"\"\n        # url = testcase.live_server_url + take.url\n        url = testcase.base_url + take.url\n\n        logger.debug(Checker.get_selenium_response)\n        logger.debug(f\"{url=}\")\n        logger.debug(f\"{take.method=}\")\n        if take.data:\n            logger.debug(take.data)\n\n\n        response = SeleniumResponse(testcase.driver)\n\n\n        if take.method == http.HTTPMethod.GET:\n            testcase.driver.get(url)\n        if take.method == http.HTTPMethod.POST:\n            # TODO mad: improve and or document\n            method_name = take.url_name.replace(\":\", \"_\")\n            method_name =  f\"post_{method_name}\"\n            post_method = getattr(cls.selenium_module, method_name)\n            post_method(testcase, url, take.data)\n\n        # time.sleep(1000)\n\n\n        return response \n\n    @staticmethod\n    def get_http_response(testcase: RemoteBackendTestCase, take: Take) -&gt; requests.Response:\n\n        url = testcase.base_url + take.url\n\n        logger.debug(Checker.get_http_response)\n        logger.debug(f\"{url=}\")\n        logger.debug(f\"{take.method=}\")\n        if take.data:\n            logger.debug(take.data)\n\n        if take.method == http.HTTPMethod.GET:\n            response = testcase.session.get(\n                url,\n                data=take.data,\n                headers=testcase.headers,\n            )\n        elif take.method == http.HTTPMethod.POST:\n            response = testcase.session.post(\n                testcase.base_url + take.url,\n                take.data,\n                headers=testcase.headers,\n            )\n        else:\n            raise NotImplementedError(take.method)\n\n        return response\n\n    # CHECKS\n    ################################\n\n    @staticmethod\n    def exec_check(\n        testcase: SceneryTestCase,\n        response: ResponseProtocol,\n        check: Check,\n    ) -&gt; None:\n        \"\"\"Execute a specific check on an HTTP response.\n\n        This method delegates to the appropriate check method based on the instruction\n        specified in the HttpCheck object.\n\n        Args:\n            testcase (DjangoTestCase): The Django test case instance.\n            response (ResponseProtocol): The response to check.\n            check (scenery.manifest.HttpCheck): The check to perform on the response.\n\n        Raises:\n            NotImplementedError: If the check instruction is not implemented.\n        \"\"\"\n\n        logger.debug(check)\n\n        if check.instruction == DirectiveCommand.STATUS_CODE:\n            Checker.check_status_code(testcase, response, check.args)\n        elif check.instruction == DirectiveCommand.REDIRECT_URL:\n            Checker.check_redirect_url(testcase, response, check.args)\n        elif check.instruction == DirectiveCommand.COUNT_INSTANCES:\n            Checker.check_count_instances(testcase, response, check.args)\n        elif check.instruction == DirectiveCommand.DOM_ELEMENT:\n            Checker.check_dom(testcase, response, check.args)\n        elif check.instruction == DirectiveCommand.JSON:\n            Checker.check_json(testcase, response, check.args)\n        elif check.instruction == DirectiveCommand.FIELD_OF_INSTANCE:\n            Checker.check_field_of_instance(testcase, response, check.args)\n        # NOTE mad: do not erase\n        # elif check.instruction == scenery.manifest.DirectiveCommand.JS_VARIABLE:\n        #     Checker.check_js_variable(testcase, response, check.args)\n        # elif check.instruction == scenery.manifest.DirectiveCommand.JS_STRINGIFY:\n        #     Checker.check_js_stringify(testcase, response, check.args)\n        else:\n            raise NotImplementedError(check)\n\n\n    @staticmethod\n    def check_status_code(\n        testcase: SceneryTestCase,\n        response: ResponseProtocol,\n        args: int,\n    ) -&gt; None:\n        \"\"\"Check if the response status code matches the expected code.\n\n        Args:\n            testcase (DjangoTestCase): The Django test case instance.\n            response (ResponseProtocol): The HTTP response to check.\n            args (int): The expected status code.\n        \"\"\"\n        testcase.assertEqual(\n            response.status_code,\n            args,\n            f\"Expected status code {args}, but got {response.status_code}\",\n        )\n\n    @staticmethod\n    def check_redirect_url(\n        testcase: SceneryTestCase,\n        response: ResponseProtocol,\n        args: str,\n    ) -&gt; None:\n        \"\"\"Check if the response redirect URL matches the expected URL.\n\n        Args:\n            testcase (DjangoTestCase): The Django test case instance.\n            response (django.http.HttpResponseRedirect): The HTTP redirect response to check.\n            args (str): The expected redirect URL.\n        \"\"\"\n        # NOTE mad: this will fail when we try with frontend for login etc... \n        # but I skip those kind of test in the method builder\n        testcase.assertIsInstance(\n            response,\n            django.http.HttpResponseRedirect,\n            f\"Expected HttpResponseRedirect but got {type(response)}\",\n        )\n        # FIXME mad: this is done for static type checking\n        redirect = cast(django.http.HttpResponseRedirect, response)\n        testcase.assertEqual(\n            redirect.url,\n            args,\n            f\"Expected redirect URL '{args}', but got '{redirect.url}'\",\n        )\n\n    @staticmethod\n    def check_count_instances(\n        testcase: SceneryTestCase,\n        response: ResponseProtocol,\n        args: dict,\n    ) -&gt; None:\n        \"\"\"Check if the count of model instances matches the expected count.\n\n        Args:\n            testcase (DjangoTestCase): The Django test case instance.\n            response (ResponseProtocol): The HTTP response (not used in this check).\n            args (dict): A dictionary containing 'model' (the model class) and 'n' (expected count).\n        \"\"\"\n        instances = list(args[\"model\"].objects.all())\n        testcase.assertEqual(\n            len(instances),\n            args[\"n\"],\n            f\"Expected {args['n']} instances of {args['model'].__name__}, but found {len(instances)}\",\n        )\n\n    @staticmethod\n    def check_dom(\n        testcase: SceneryTestCase,\n        response: ResponseProtocol,\n        args: dict[DomArgument, Any],\n    ) -&gt; None:\n        \"\"\"Check for the presence and properties of DOM elements in the response content.\n\n        This method uses BeautifulSoup to parse the response content and perform various\n        checks on DOM elements as specified in the args dictionary.\n\n        Args:\n            testcase (DjangoTestCase): The Django test case instance.\n            response (django.ResponseProtocol): The HTTP response to check.\n            args (dict): A dictionary of DomArgument keys and their corresponding values,\n                         specifying the checks to perform.\n\n        Raises:\n            ValueError: If neither 'find' nor 'find_all' arguments are provided in args.\n        \"\"\"\n        # NOTE mad: this is incredibly important for the frontend test\n        time.sleep(1)\n\n        soup = bs4.BeautifulSoup(response.content, \"html.parser\")\n\n        # Apply the scope\n        if scope := args.get(DomArgument.SCOPE):\n            scope_result = soup.find(**scope)\n            testcase.assertIsNotNone(\n                scope,\n                f\"Expected to find an element matching {args[DomArgument.SCOPE]}, but found none\",\n            )\n        else:\n            scope_result = soup\n\n        # FIXME mad: we inforce type checking by regarding bs4 objects as Tag\n        scope_result = cast(bs4.Tag, scope_result)\n\n        # Locate the element(s)\n        if args.get(DomArgument.FIND_ALL):\n            dom_elements = scope_result.find_all(**args[DomArgument.FIND_ALL])\n            testcase.assertGreaterEqual(\n                len(dom_elements),\n                1,\n                f\"Expected to find at least one element matching {args[DomArgument.FIND_ALL]}, but found none\",\n            )\n        elif args.get(DomArgument.FIND):\n            dom_element = scope_result.find(**args[DomArgument.FIND])\n            testcase.assertIsNotNone(\n                dom_element,\n                f\"Expected to find an element matching {args[DomArgument.FIND]}, but found none\",\n            )\n            dom_elements = bs4.ResultSet(source=bs4.SoupStrainer(), result=[dom_element])\n        else:\n            raise ValueError(\"Neither find of find_all argument provided\")\n        # FIXME mad: as I enforce the results to be a bs4.ResultSet[bs4.Tag] above\n        dom_elements = cast(bs4.ResultSet[bs4.Tag], dom_elements)\n\n        # Perform the additional checks\n        if count := args.get(DomArgument.COUNT):\n            testcase.assertEqual(\n                len(dom_elements),\n                count,\n                f\"Expected to find {count} elements, but found {len(dom_elements)}\",\n            )\n        for dom_element in dom_elements:\n            if text := args.get(DomArgument.TEXT):\n                testcase.assertEqual(\n                    dom_element.text,\n                    text,\n                    f\"Expected element text to be '{text}', but got '{dom_element.text}'\",\n                )\n            if attribute := args.get(DomArgument.ATTRIBUTE):\n\n                if value := attribute.get(\"value\"):\n                    # TODO mad: should this move to manifest parser?\n                    # in manifest _format_dom_element should be used here, or even before and just disappear\n                    if isinstance(value, (str, list)):\n                        pass\n                    elif isinstance(value, int):\n                        value = str(value)\n                    else:\n                        raise TypeError(\n                            f\"attribute value can only by `str` or `list[str]` not '{type(value)}'\"\n                        )\n                    testcase.assertEqual(\n                        dom_element[attribute[\"name\"]],\n                        value,\n                        f\"Expected attribute '{attribute['name']}' to have value '{value}', but got '{dom_element[attribute['name']]}'\",\n                    )\n                elif regex := attribute.get(\"regex\"):\n\n                    testcase.assertRegex(\n                        dom_element[attribute[\"name\"]],\n                        regex,\n                        f\"Expected attribute '{attribute['name']}' to match regex '{regex}', but got '{dom_element[attribute['name']]}'\",\n                    )\n                if exepected_value_from_ff := attribute.get(\"json_stringify\"):\n\n                    if isinstance(testcase, DjangoFrontendTestCase):\n                        # NOTE mad: we cannot anotate it.\n                        value_from_ff = testcase.driver.execute_script( # type: ignore[no-untyped-call]\n                        f\"return JSON.stringify({dom_element[attribute['name']]})\"\n                    )\n                    else:\n                        raise Exception(\"json_stringify can only be called for frontend tests\")\n\n                    if exepected_value_from_ff == \"_\":\n                        # NOTE mad: this means we only want to check the value is a valid json string\n                        pass\n                    else:\n                        value_from_ff = json.loads(value_from_ff)\n                        testcase.assertEqual(\n                            value_from_ff,\n                            exepected_value_from_ff,\n                            f\"Expected attribute '{attribute['name']}' to have value '{exepected_value_from_ff}', but got '{value_from_ff}'\",\n                        )\n\n    @staticmethod\n    def check_json(\n        testcase: SceneryTestCase,\n        response: ResponseProtocol,\n        args: dict,\n    ) -&gt; None:\n        # print(f\"{response.json()=}\")\n        testcase.assertIsInstance(response, django.http.JsonResponse)\n        # FIXME\n        data = response.json() # type: ignore [attr-defined]\n        testcase.assertEqual(data[args[\"key\"]], args[\"value\"])\n\n\n    @staticmethod\n    def check_field_of_instance(\n        testcase: SceneryTestCase,\n        response: ResponseProtocol,\n        args: dict,\n    ) -&gt; None:\n\n\n        instances = list(args[\"find\"][\"model\"].objects.all())\n        if len(instances) != 1:\n            testcase.fail(f\"Checking the {args['field']} field of {args['find']['model']} requires that there is a single instance in the db, but found {len(instances)}.\")\n\n        instance = instances[0]\n        field_value = getattr(instance, args[\"field\"])\n        testcase.assertEqual(\n            field_value, \n            args[\"value\"],\n            f\"{args['find']['model'].__name__}.{args['field']} = {field_value} but expected {args['value']}\"\n        )\n</code></pre>"},{"location":"api/#scenery.response_checker.Checker.check_count_instances","title":"<code>check_count_instances(testcase, response, args)</code>  <code>staticmethod</code>","text":"<p>Check if the count of model instances matches the expected count.</p> <p>Parameters:</p> Name Type Description Default <code>testcase</code> <code>DjangoTestCase</code> <p>The Django test case instance.</p> required <code>response</code> <code>ResponseProtocol</code> <p>The HTTP response (not used in this check).</p> required <code>args</code> <code>dict</code> <p>A dictionary containing 'model' (the model class) and 'n' (expected count).</p> required Source code in <code>scenery/response_checker.py</code> <pre><code>@staticmethod\ndef check_count_instances(\n    testcase: SceneryTestCase,\n    response: ResponseProtocol,\n    args: dict,\n) -&gt; None:\n    \"\"\"Check if the count of model instances matches the expected count.\n\n    Args:\n        testcase (DjangoTestCase): The Django test case instance.\n        response (ResponseProtocol): The HTTP response (not used in this check).\n        args (dict): A dictionary containing 'model' (the model class) and 'n' (expected count).\n    \"\"\"\n    instances = list(args[\"model\"].objects.all())\n    testcase.assertEqual(\n        len(instances),\n        args[\"n\"],\n        f\"Expected {args['n']} instances of {args['model'].__name__}, but found {len(instances)}\",\n    )\n</code></pre>"},{"location":"api/#scenery.response_checker.Checker.check_dom","title":"<code>check_dom(testcase, response, args)</code>  <code>staticmethod</code>","text":"<p>Check for the presence and properties of DOM elements in the response content.</p> <p>This method uses BeautifulSoup to parse the response content and perform various checks on DOM elements as specified in the args dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>testcase</code> <code>DjangoTestCase</code> <p>The Django test case instance.</p> required <code>response</code> <code>ResponseProtocol</code> <p>The HTTP response to check.</p> required <code>args</code> <code>dict</code> <p>A dictionary of DomArgument keys and their corresponding values,          specifying the checks to perform.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither 'find' nor 'find_all' arguments are provided in args.</p> Source code in <code>scenery/response_checker.py</code> <pre><code>@staticmethod\ndef check_dom(\n    testcase: SceneryTestCase,\n    response: ResponseProtocol,\n    args: dict[DomArgument, Any],\n) -&gt; None:\n    \"\"\"Check for the presence and properties of DOM elements in the response content.\n\n    This method uses BeautifulSoup to parse the response content and perform various\n    checks on DOM elements as specified in the args dictionary.\n\n    Args:\n        testcase (DjangoTestCase): The Django test case instance.\n        response (django.ResponseProtocol): The HTTP response to check.\n        args (dict): A dictionary of DomArgument keys and their corresponding values,\n                     specifying the checks to perform.\n\n    Raises:\n        ValueError: If neither 'find' nor 'find_all' arguments are provided in args.\n    \"\"\"\n    # NOTE mad: this is incredibly important for the frontend test\n    time.sleep(1)\n\n    soup = bs4.BeautifulSoup(response.content, \"html.parser\")\n\n    # Apply the scope\n    if scope := args.get(DomArgument.SCOPE):\n        scope_result = soup.find(**scope)\n        testcase.assertIsNotNone(\n            scope,\n            f\"Expected to find an element matching {args[DomArgument.SCOPE]}, but found none\",\n        )\n    else:\n        scope_result = soup\n\n    # FIXME mad: we inforce type checking by regarding bs4 objects as Tag\n    scope_result = cast(bs4.Tag, scope_result)\n\n    # Locate the element(s)\n    if args.get(DomArgument.FIND_ALL):\n        dom_elements = scope_result.find_all(**args[DomArgument.FIND_ALL])\n        testcase.assertGreaterEqual(\n            len(dom_elements),\n            1,\n            f\"Expected to find at least one element matching {args[DomArgument.FIND_ALL]}, but found none\",\n        )\n    elif args.get(DomArgument.FIND):\n        dom_element = scope_result.find(**args[DomArgument.FIND])\n        testcase.assertIsNotNone(\n            dom_element,\n            f\"Expected to find an element matching {args[DomArgument.FIND]}, but found none\",\n        )\n        dom_elements = bs4.ResultSet(source=bs4.SoupStrainer(), result=[dom_element])\n    else:\n        raise ValueError(\"Neither find of find_all argument provided\")\n    # FIXME mad: as I enforce the results to be a bs4.ResultSet[bs4.Tag] above\n    dom_elements = cast(bs4.ResultSet[bs4.Tag], dom_elements)\n\n    # Perform the additional checks\n    if count := args.get(DomArgument.COUNT):\n        testcase.assertEqual(\n            len(dom_elements),\n            count,\n            f\"Expected to find {count} elements, but found {len(dom_elements)}\",\n        )\n    for dom_element in dom_elements:\n        if text := args.get(DomArgument.TEXT):\n            testcase.assertEqual(\n                dom_element.text,\n                text,\n                f\"Expected element text to be '{text}', but got '{dom_element.text}'\",\n            )\n        if attribute := args.get(DomArgument.ATTRIBUTE):\n\n            if value := attribute.get(\"value\"):\n                # TODO mad: should this move to manifest parser?\n                # in manifest _format_dom_element should be used here, or even before and just disappear\n                if isinstance(value, (str, list)):\n                    pass\n                elif isinstance(value, int):\n                    value = str(value)\n                else:\n                    raise TypeError(\n                        f\"attribute value can only by `str` or `list[str]` not '{type(value)}'\"\n                    )\n                testcase.assertEqual(\n                    dom_element[attribute[\"name\"]],\n                    value,\n                    f\"Expected attribute '{attribute['name']}' to have value '{value}', but got '{dom_element[attribute['name']]}'\",\n                )\n            elif regex := attribute.get(\"regex\"):\n\n                testcase.assertRegex(\n                    dom_element[attribute[\"name\"]],\n                    regex,\n                    f\"Expected attribute '{attribute['name']}' to match regex '{regex}', but got '{dom_element[attribute['name']]}'\",\n                )\n            if exepected_value_from_ff := attribute.get(\"json_stringify\"):\n\n                if isinstance(testcase, DjangoFrontendTestCase):\n                    # NOTE mad: we cannot anotate it.\n                    value_from_ff = testcase.driver.execute_script( # type: ignore[no-untyped-call]\n                    f\"return JSON.stringify({dom_element[attribute['name']]})\"\n                )\n                else:\n                    raise Exception(\"json_stringify can only be called for frontend tests\")\n\n                if exepected_value_from_ff == \"_\":\n                    # NOTE mad: this means we only want to check the value is a valid json string\n                    pass\n                else:\n                    value_from_ff = json.loads(value_from_ff)\n                    testcase.assertEqual(\n                        value_from_ff,\n                        exepected_value_from_ff,\n                        f\"Expected attribute '{attribute['name']}' to have value '{exepected_value_from_ff}', but got '{value_from_ff}'\",\n                    )\n</code></pre>"},{"location":"api/#scenery.response_checker.Checker.check_redirect_url","title":"<code>check_redirect_url(testcase, response, args)</code>  <code>staticmethod</code>","text":"<p>Check if the response redirect URL matches the expected URL.</p> <p>Parameters:</p> Name Type Description Default <code>testcase</code> <code>DjangoTestCase</code> <p>The Django test case instance.</p> required <code>response</code> <code>HttpResponseRedirect</code> <p>The HTTP redirect response to check.</p> required <code>args</code> <code>str</code> <p>The expected redirect URL.</p> required Source code in <code>scenery/response_checker.py</code> <pre><code>@staticmethod\ndef check_redirect_url(\n    testcase: SceneryTestCase,\n    response: ResponseProtocol,\n    args: str,\n) -&gt; None:\n    \"\"\"Check if the response redirect URL matches the expected URL.\n\n    Args:\n        testcase (DjangoTestCase): The Django test case instance.\n        response (django.http.HttpResponseRedirect): The HTTP redirect response to check.\n        args (str): The expected redirect URL.\n    \"\"\"\n    # NOTE mad: this will fail when we try with frontend for login etc... \n    # but I skip those kind of test in the method builder\n    testcase.assertIsInstance(\n        response,\n        django.http.HttpResponseRedirect,\n        f\"Expected HttpResponseRedirect but got {type(response)}\",\n    )\n    # FIXME mad: this is done for static type checking\n    redirect = cast(django.http.HttpResponseRedirect, response)\n    testcase.assertEqual(\n        redirect.url,\n        args,\n        f\"Expected redirect URL '{args}', but got '{redirect.url}'\",\n    )\n</code></pre>"},{"location":"api/#scenery.response_checker.Checker.check_status_code","title":"<code>check_status_code(testcase, response, args)</code>  <code>staticmethod</code>","text":"<p>Check if the response status code matches the expected code.</p> <p>Parameters:</p> Name Type Description Default <code>testcase</code> <code>DjangoTestCase</code> <p>The Django test case instance.</p> required <code>response</code> <code>ResponseProtocol</code> <p>The HTTP response to check.</p> required <code>args</code> <code>int</code> <p>The expected status code.</p> required Source code in <code>scenery/response_checker.py</code> <pre><code>@staticmethod\ndef check_status_code(\n    testcase: SceneryTestCase,\n    response: ResponseProtocol,\n    args: int,\n) -&gt; None:\n    \"\"\"Check if the response status code matches the expected code.\n\n    Args:\n        testcase (DjangoTestCase): The Django test case instance.\n        response (ResponseProtocol): The HTTP response to check.\n        args (int): The expected status code.\n    \"\"\"\n    testcase.assertEqual(\n        response.status_code,\n        args,\n        f\"Expected status code {args}, but got {response.status_code}\",\n    )\n</code></pre>"},{"location":"api/#scenery.response_checker.Checker.exec_check","title":"<code>exec_check(testcase, response, check)</code>  <code>staticmethod</code>","text":"<p>Execute a specific check on an HTTP response.</p> <p>This method delegates to the appropriate check method based on the instruction specified in the HttpCheck object.</p> <p>Parameters:</p> Name Type Description Default <code>testcase</code> <code>DjangoTestCase</code> <p>The Django test case instance.</p> required <code>response</code> <code>ResponseProtocol</code> <p>The response to check.</p> required <code>check</code> <code>HttpCheck</code> <p>The check to perform on the response.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the check instruction is not implemented.</p> Source code in <code>scenery/response_checker.py</code> <pre><code>@staticmethod\ndef exec_check(\n    testcase: SceneryTestCase,\n    response: ResponseProtocol,\n    check: Check,\n) -&gt; None:\n    \"\"\"Execute a specific check on an HTTP response.\n\n    This method delegates to the appropriate check method based on the instruction\n    specified in the HttpCheck object.\n\n    Args:\n        testcase (DjangoTestCase): The Django test case instance.\n        response (ResponseProtocol): The response to check.\n        check (scenery.manifest.HttpCheck): The check to perform on the response.\n\n    Raises:\n        NotImplementedError: If the check instruction is not implemented.\n    \"\"\"\n\n    logger.debug(check)\n\n    if check.instruction == DirectiveCommand.STATUS_CODE:\n        Checker.check_status_code(testcase, response, check.args)\n    elif check.instruction == DirectiveCommand.REDIRECT_URL:\n        Checker.check_redirect_url(testcase, response, check.args)\n    elif check.instruction == DirectiveCommand.COUNT_INSTANCES:\n        Checker.check_count_instances(testcase, response, check.args)\n    elif check.instruction == DirectiveCommand.DOM_ELEMENT:\n        Checker.check_dom(testcase, response, check.args)\n    elif check.instruction == DirectiveCommand.JSON:\n        Checker.check_json(testcase, response, check.args)\n    elif check.instruction == DirectiveCommand.FIELD_OF_INSTANCE:\n        Checker.check_field_of_instance(testcase, response, check.args)\n    # NOTE mad: do not erase\n    # elif check.instruction == scenery.manifest.DirectiveCommand.JS_VARIABLE:\n    #     Checker.check_js_variable(testcase, response, check.args)\n    # elif check.instruction == scenery.manifest.DirectiveCommand.JS_STRINGIFY:\n    #     Checker.check_js_stringify(testcase, response, check.args)\n    else:\n        raise NotImplementedError(check)\n</code></pre>"},{"location":"api/#scenery.response_checker.Checker.get_django_client_response","title":"<code>get_django_client_response(testcase, take)</code>  <code>staticmethod</code>","text":"<p>Execute an HTTP request based on the given HttpTake object.</p> <p>Parameters:</p> Name Type Description Default <code>testcase</code> <code>BackendDjangoTestCase</code> <p>The Django testcase instance.</p> required <code>take</code> <code>HttpTake</code> <p>The HttpTake object specifying the request details.</p> required <p>Returns:</p> Type Description <code>HttpResponse</code> <p>django.http.HttpResponse: The response from the HTTP request.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the HTTP method specified in the take is not implemented.</p> Source code in <code>scenery/response_checker.py</code> <pre><code>@staticmethod\ndef get_django_client_response(\n    testcase: DjangoBackendTestCase, take: Take\n) -&gt; django.http.HttpResponse:\n    \"\"\"Execute an HTTP request based on the given HttpTake object.\n\n    Args:\n        testcase (BackendDjangoTestCase): The Django testcase instance.\n        take (scenery.manifest.HttpTake): The HttpTake object specifying the request details.\n\n    Returns:\n        django.http.HttpResponse: The response from the HTTP request.\n\n    Raises:\n        NotImplementedError: If the HTTP method specified in the take is not implemented.\n    \"\"\"\n    logger.debug(Checker.get_django_client_response)\n    logger.debug(f\"{take.url=}\")\n    logger.debug(f\"{take.method=}\")\n    if take.data:\n        logger.debug(take.data)\n\n    if take.method == http.HTTPMethod.GET:\n        response = testcase.client.get(\n            take.url,\n            take.data,\n        )\n    elif take.method == http.HTTPMethod.POST:\n        response = testcase.client.post(\n            take.url,\n            take.data,\n        )\n    else:\n        raise NotImplementedError(take.method)\n\n    # FIXME mad: this one is a bit puzzling to me\n    # running mypy I get:\n    # Incompatible return value type (got \"_MonkeyPatchedWSGIResponse\", expected \"HttpResponse\")\n    return response # type: ignore[return-value]\n</code></pre>"},{"location":"api/#scenery.response_checker.Checker.get_selenium_response","title":"<code>get_selenium_response(testcase, take)</code>  <code>classmethod</code>","text":"<p>Create a SeleniumResponse by executing a request through Selenium WebDriver.</p> <p>This function handles both GET and POST requests through Selenium. For POST requests, it dynamically loads and executes request handlers from a configured Selenium module.</p> <p>Parameters:</p> Name Type Description Default <code>testcase</code> <code>FrontendDjangoTestCase</code> <p>The test case instance containing the Selenium WebDriver and live server URL.</p> required <code>take</code> <code>Take</code> <p>The request specification containing method, URL, and data for the request to be executed.</p> required <p>Returns:</p> Name Type Description <code>SeleniumResponse</code> <code>SeleniumResponse</code> <p>A wrapper containing the response from the Selenium-driven request.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the SCENERY_POST_REQUESTS_INSTRUCTIONS_SELENIUM module cannot be loaded.</p> <code>AttributeError</code> <p>If a POST request handler method cannot be found in the Selenium module.</p> Notes <ul> <li>For POST requests, the handler method name is derived from the URL name by replacing ':' with '' and prefixing with 'post'.</li> <li>The Selenium module path must be specified in the SCENERY_POST_REQUESTS_INSTRUCTIONS_SELENIUM environment variable.</li> </ul> Source code in <code>scenery/response_checker.py</code> <pre><code>@classmethod\ndef get_selenium_response(\n    cls, testcase: DjangoFrontendTestCase | RemoteFrontendTestCase, take: Take\n) -&gt; SeleniumResponse:\n    \"\"\"Create a SeleniumResponse by executing a request through Selenium WebDriver.\n\n    This function handles both GET and POST requests through Selenium. For POST requests,\n    it dynamically loads and executes request handlers from a configured Selenium module.\n\n    Args:\n        testcase (FrontendDjangoTestCase): The test case instance containing\n            the Selenium WebDriver and live server URL.\n        take (Take): The request specification containing method, URL, and data\n            for the request to be executed.\n\n    Returns:\n        SeleniumResponse: A wrapper containing the response from the Selenium-driven request.\n\n    Raises:\n        ImportError: If the SCENERY_POST_REQUESTS_INSTRUCTIONS_SELENIUM module cannot be loaded.\n        AttributeError: If a POST request handler method cannot be found in the Selenium module.\n\n    Notes:\n        - For POST requests, the handler method name is derived from the URL name by\n        replacing ':' with '_' and prefixing with 'post_'.\n        - The Selenium module path must be specified in the SCENERY_POST_REQUESTS_INSTRUCTIONS_SELENIUM\n        environment variable.\n    \"\"\"\n    # url = testcase.live_server_url + take.url\n    url = testcase.base_url + take.url\n\n    logger.debug(Checker.get_selenium_response)\n    logger.debug(f\"{url=}\")\n    logger.debug(f\"{take.method=}\")\n    if take.data:\n        logger.debug(take.data)\n\n\n    response = SeleniumResponse(testcase.driver)\n\n\n    if take.method == http.HTTPMethod.GET:\n        testcase.driver.get(url)\n    if take.method == http.HTTPMethod.POST:\n        # TODO mad: improve and or document\n        method_name = take.url_name.replace(\":\", \"_\")\n        method_name =  f\"post_{method_name}\"\n        post_method = getattr(cls.selenium_module, method_name)\n        post_method(testcase, url, take.data)\n\n    # time.sleep(1000)\n\n\n    return response \n</code></pre>"},{"location":"api/#scenery.response_checker.ResponseProtocol","title":"<code>ResponseProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>A protocol for HTTP responses, covering both basic Django http response and from Selenium Driver.</p> Source code in <code>scenery/response_checker.py</code> <pre><code>class ResponseProtocol(Protocol):\n    \"\"\"A protocol for HTTP responses, covering both basic Django http response and from Selenium Driver.\"\"\"\n\n    @property\n    def status_code(self) -&gt; int:\n        \"\"\"The HTTP status code of the response.\"\"\"\n\n    @property\n    def headers(self) -&gt; Mapping[str, str]:\n        \"\"\"The headers of the response.\"\"\"\n\n    @property\n    def content(self) -&gt; Any:\n        \"\"\"The content of the response.\"\"\"\n</code></pre>"},{"location":"api/#scenery.response_checker.ResponseProtocol.content","title":"<code>content: Any</code>  <code>property</code>","text":"<p>The content of the response.</p>"},{"location":"api/#scenery.response_checker.ResponseProtocol.headers","title":"<code>headers: Mapping[str, str]</code>  <code>property</code>","text":"<p>The headers of the response.</p>"},{"location":"api/#scenery.response_checker.ResponseProtocol.status_code","title":"<code>status_code: int</code>  <code>property</code>","text":"<p>The HTTP status code of the response.</p>"},{"location":"api/#scenery.response_checker.SeleniumResponse","title":"<code>SeleniumResponse</code>","text":"<p>               Bases: <code>ResponseProtocol</code></p> <p>A response wrapper class for Selenium WebDriver operations.</p> <p>This class implements the ResponseProtocol interface for Selenium WebDriver, providing access to response data like headers, content, and charset. Note that some HTTP-specific features like status codes are not available through Selenium.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>Chrome</code> <p>The Selenium Chrome WebDriver instance to wrap.</p> required <p>Attributes:</p> Name Type Description <code>driver</code> <code>Chrome</code> <p>The wrapped Selenium WebDriver instance.</p> <code>_headers</code> <code>dict[str, str]</code> <p>Dictionary storing response headers.</p> Properties <p>status_code (int): Not implemented for Selenium responses. headers (dict[str, str]): Dictionary of response headers. content (Any): Page source of the current webpage. charset (str): Character encoding of the response.</p> <p>Methods:</p> Name Description <code>has_header</code> <p>str) -&gt; bool: Check if a header exists in the response.</p> Source code in <code>scenery/response_checker.py</code> <pre><code>class SeleniumResponse(ResponseProtocol):\n    \"\"\"A response wrapper class for Selenium WebDriver operations.\n\n    This class implements the ResponseProtocol interface for Selenium WebDriver,\n    providing access to response data like headers, content, and charset. Note that\n    some HTTP-specific features like status codes are not available through Selenium.\n\n    Args:\n        driver (webdriver.Chrome): The Selenium Chrome WebDriver instance to wrap.\n\n    Attributes:\n        driver (webdriver.Chrome): The wrapped Selenium WebDriver instance.\n        _headers (dict[str, str]): Dictionary storing response headers.\n\n    Properties:\n        status_code (int): Not implemented for Selenium responses.\n        headers (dict[str, str]): Dictionary of response headers.\n        content (Any): Page source of the current webpage.\n        charset (str): Character encoding of the response.\n\n    Methods:\n        has_header(header_name: str) -&gt; bool: Check if a header exists in the response.\n    \"\"\"\n\n    def __init__(\n        self, \n        driver: webdriver.Chrome,\n        ) -&gt; None:\n        self.driver = driver\n        self._headers : dict[str, str] = {}\n\n    @property\n    def status_code(self) -&gt; int:\n        \"\"\"Not implemented for Selenium responses.\"\"\"\n        # NOTE mad: this is probably hard to solve in general\n        # we can't use Selenium for the status code\n        raise NotImplementedError\n\n    @property\n    def headers(self) -&gt; dict[str, str]:\n        \"\"\"Dictionary of response headers.\"\"\"\n        return self._headers\n\n    @property\n    def content(self) -&gt; Any:\n        \"\"\"Page source of the current webpage.\"\"\"\n        return self.driver.page_source\n\n    @property\n    def charset(self) -&gt; str | None:\n        \"\"\"Character encoding of the response.\"\"\"\n        # return None\n        return None\n\n    def has_header(self, header_name: str) -&gt; bool:\n        \"\"\"Check if a header exists in the response.\"\"\"\n        return header_name in self._headers\n\n    def __getitem__(self, header_name: str) -&gt; str:\n        return self._headers[header_name]\n\n    def __setitem__(self, header_name: str, value: str) -&gt; None:\n        self._headers[header_name] = value\n</code></pre>"},{"location":"api/#scenery.response_checker.SeleniumResponse.charset","title":"<code>charset: str | None</code>  <code>property</code>","text":"<p>Character encoding of the response.</p>"},{"location":"api/#scenery.response_checker.SeleniumResponse.content","title":"<code>content: Any</code>  <code>property</code>","text":"<p>Page source of the current webpage.</p>"},{"location":"api/#scenery.response_checker.SeleniumResponse.headers","title":"<code>headers: dict[str, str]</code>  <code>property</code>","text":"<p>Dictionary of response headers.</p>"},{"location":"api/#scenery.response_checker.SeleniumResponse.status_code","title":"<code>status_code: int</code>  <code>property</code>","text":"<p>Not implemented for Selenium responses.</p>"},{"location":"api/#scenery.response_checker.SeleniumResponse.has_header","title":"<code>has_header(header_name)</code>","text":"<p>Check if a header exists in the response.</p> Source code in <code>scenery/response_checker.py</code> <pre><code>def has_header(self, header_name: str) -&gt; bool:\n    \"\"\"Check if a header exists in the response.\"\"\"\n    return header_name in self._headers\n</code></pre>"},{"location":"api/#set-up-handler","title":"Set up handler","text":"<p>Execute instructions used in <code>TestCase.setUp</code> and <code>TestCase.setUpTestData</code> provided in the manifest.</p>"},{"location":"api/#scenery.set_up_handler.SetUpHandler","title":"<code>SetUpHandler</code>","text":"<p>Responsible for executing instructions used in <code>TestCase.setUp</code> and <code>TestCase.setUpTestData</code> provided in the manifest.</p> <p>This class dynamically imports and executes setup instructions specified in the test manifest. It is typically used by the MethodBuilder to construct setup methods for test cases.</p> <p>Attributes:</p> Name Type Description <code>module</code> <p>The imported module containing setup instruction implementations.</p> <code>logger</code> <p>A logger instance for debug output.</p> Source code in <code>scenery/set_up_handler.py</code> <pre><code>class SetUpHandler:\n    \"\"\"Responsible for executing instructions used in `TestCase.setUp` and `TestCase.setUpTestData` provided in the manifest.\n\n    This class dynamically imports and executes setup instructions specified in the test manifest.\n    It is typically used by the MethodBuilder to construct setup methods for test cases.\n\n    Attributes:\n        module: The imported module containing setup instruction implementations.\n        logger: A logger instance for debug output.\n    \"\"\"\n\n    instructions_module = importlib.import_module(os.environ[\"SCENERY_SET_UP_INSTRUCTIONS\"])\n    # selenium_module = importlib.import_module(os.environ[\"SCENERY_SET_UP_INSTRUCTIONS_SELENIUM\"])\n\n    @staticmethod\n    def exec_set_up_instruction(\n        # NOTE mad: it either takes the instance or the class\n        # depending whether it is class method or not\n        # (setUp vs. setUpClass)\n        testcase: SceneryTestCase | type[SceneryTestCase],\n        instruction: SetUpInstruction,\n    ) -&gt; None:\n        \"\"\"Execute the method corresponding to the SetUpInstruction.\n\n        This method dynamically retrieves and executes the setup function specified\n        by the SetUpInstruction. It logs the execution for debugging purposes.\n\n        Args:\n            testcase (SceneryTestCase): The Scenery test case class or instance.\n            instruction (scenery.manifest.SetUpInstruction): The setup instruction to execute.\n\n        Raises:\n            AttributeError: If the specified setup function is not found in the imported module.\n        \"\"\"\n        func = getattr(SetUpHandler.instructions_module, instruction.command)\n\n\n        if isinstance(testcase, (RemoteBackendTestCase, LoadTestCase)) and hasattr(func, \"_local_execution_only\"):\n            pass\n        else:\n            logger.debug(instruction)\n            func(testcase, **instruction.args)\n</code></pre>"},{"location":"api/#scenery.set_up_handler.SetUpHandler.exec_set_up_instruction","title":"<code>exec_set_up_instruction(testcase, instruction)</code>  <code>staticmethod</code>","text":"<p>Execute the method corresponding to the SetUpInstruction.</p> <p>This method dynamically retrieves and executes the setup function specified by the SetUpInstruction. It logs the execution for debugging purposes.</p> <p>Parameters:</p> Name Type Description Default <code>testcase</code> <code>SceneryTestCase</code> <p>The Scenery test case class or instance.</p> required <code>instruction</code> <code>SetUpInstruction</code> <p>The setup instruction to execute.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the specified setup function is not found in the imported module.</p> Source code in <code>scenery/set_up_handler.py</code> <pre><code>@staticmethod\ndef exec_set_up_instruction(\n    # NOTE mad: it either takes the instance or the class\n    # depending whether it is class method or not\n    # (setUp vs. setUpClass)\n    testcase: SceneryTestCase | type[SceneryTestCase],\n    instruction: SetUpInstruction,\n) -&gt; None:\n    \"\"\"Execute the method corresponding to the SetUpInstruction.\n\n    This method dynamically retrieves and executes the setup function specified\n    by the SetUpInstruction. It logs the execution for debugging purposes.\n\n    Args:\n        testcase (SceneryTestCase): The Scenery test case class or instance.\n        instruction (scenery.manifest.SetUpInstruction): The setup instruction to execute.\n\n    Raises:\n        AttributeError: If the specified setup function is not found in the imported module.\n    \"\"\"\n    func = getattr(SetUpHandler.instructions_module, instruction.command)\n\n\n    if isinstance(testcase, (RemoteBackendTestCase, LoadTestCase)) and hasattr(func, \"_local_execution_only\"):\n        pass\n    else:\n        logger.debug(instruction)\n        func(testcase, **instruction.args)\n</code></pre>"},{"location":"api/#scenery.set_up_handler.local_execution_only","title":"<code>local_execution_only(func)</code>","text":"<p>Simple decorator that marks function as executable</p> Source code in <code>scenery/set_up_handler.py</code> <pre><code>def local_execution_only(func: Callable) -&gt; Callable:\n    \"\"\"Simple decorator that marks function as executable\"\"\"\n    # NOTE mad: this type ignore is here to stay, this is the whole\n    # point to create a non existing attribute.\n    func._local_execution_only = True # type: ignore [attr-defined]\n    return func\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome.</p>"},{"location":"glossary/","title":"Glossary","text":""},{"location":"glossary/#rehearsal","title":"Rehearsal","text":"<p>Testing the scenery package itself. </p>"},{"location":"glossary/#scene","title":"Scene","text":"<p>A scene describes an event from the app perspective. It additionally describe the expected behavior of the app regarding this event by what we call a directive.</p> <p>A scene can rely on a substituable field, i.e. a field for which the value is placeholder that will be replaced by different potential values coming from what we call cases. This allows to check that the app behaves in a similar way with different values for this field. Such field can be used in the scene description or in a directive.</p>"},{"location":"glossary/#case","title":"Case","text":"<p>A case contains information that can be used to fill the substituable fields of a scene. A case has an id and a list of items. All cases applied to a given scene need to have a list of similar items. </p>"},{"location":"glossary/#take","title":"Take","text":"<p>A take is a scene in which all substituable fields have been replaced based on a particular case. We say that the take is the result of shooting the scene with a given case.</p> <p>Once shot, a directive is designated as a check.</p>"},{"location":"glossary/#manifest","title":"Manifest","text":"<p>A manifest contains all required information to build and run tests based on some scene(s) and case(s).</p>"},{"location":"installation/","title":"Installation","text":"<pre><code>pip install pca-scenery\n</code></pre>"},{"location":"manifest_specification/","title":"Manifest specification","text":"<p>See Glossary for definitions.</p>"},{"location":"manifest_specification/#basic-syntax","title":"Basic syntax","text":""},{"location":"manifest_specification/#scenes","title":"Scene(s)","text":"<p>Required.</p> <p><pre><code>scene:\n  method: ...\n  url: ...\n  data: ...\n  directives:\n  - status_code: ...\n  - redirect_url: ...\n</code></pre> or </p> <pre><code>scenes:\n- method: ...\n  url: ...\n  data: ...\n  directives:\n  - status_code: ...\n  - redirect_url: ...\n  ...\n</code></pre> <p>An HTTP scene is defined by: - a method (<code>GET</code>, <code>POST</code>, ...) - an url - some data (optional) - some url parameters (optional) - some query parameters (optional)</p> <p>An HTTP directive may be related to: - the response status code - the redirect url - some DOM element of the returned html - the state of the database (e.g. counting the instances of a model)</p> <p>See ?? for more details</p>"},{"location":"manifest_specification/#cases","title":"Case(s)","text":"<p>Optional. <pre><code>case:\n  item_1:\n    foo: ...\n  item_2:\n    bar: ...\n</code></pre> or <pre><code>cases:\n  CASE_A:\n    item_1:\n        foo: ...\n    item_2:\n      bar: ...\n  CASE_B:\n    item_1:\n        foo: ...\n    item_2:\n      bar: ...\n</code></pre></p>"},{"location":"manifest_specification/#set-up","title":"Set up","text":"<p>Two optional keys: - <code>set_up_test_data</code> - <code>set_up</code></p> <p>They contain lists of instructions executed the tests contained in the manifest.  Some instructions require keyword arguments that need to be passed as a dictionary. </p> <p>Instructions in <code>set_up_test_data</code> are executed be once before for all tests. <code>setup</code> instructions are executed before each test contained in the manifest. This is the exact same syntax and commands as for <code>set_up_test_data</code>.</p> <pre><code>set_up_test_data:\n  - reset_db\n  - create_testuser:\n      first_name : Jane\n      last_name : Doe\n      ...\n</code></pre> <p>The functions name and args should correspond to what is defined in the module attached to <code>SCENERY_SET_UP_INSTRUCTIONS</code> in <code>scenery_settings.py</code></p>"},{"location":"manifest_specification/#substituable-fields","title":"Substituable fields","text":"<p>To indicate that a field is substituable, use the <code>!case</code> tag with one of the following syntax:</p> <ol> <li>Whole item</li> </ol> <pre><code>case:\n  item: ...\nscene:\n  - ...\n    data:\n      item: !case \"item\"\n</code></pre> <ol> <li>Single field</li> </ol> <pre><code>case:\n  item:\n    foo: ...\n    bar: ...\nscene:\n  - ...\n    data:\n      item_foo: !case \"item:foo\"\n</code></pre>"},{"location":"manifest_specification/#common-items","title":"Common items","text":"<p>Common items allow you to use one single YAML file to store some data that you can refer to in your manifest. This helps you keeping the code base more readable. For instance, it can help store the information of your test user. HERE</p> <p>The path to the <code>.yml</code> file is defined under <code>SCENERY_COMMON_ITEMS</code> in <code>scenery_settings.py</code></p> <pre><code>ITEM_ID1:\n  foo: 0\nITEM_ID2:\n  bar: \"a\" \n</code></pre> <p>In the manifest, two possible syntax can be used with the <code>!common-item</code> tag</p> <ol> <li> <p>access directly the item <pre><code>set_up_test_data:\n    - reset_db\n    - create_testuser: !common-item TESTUSER\n</code></pre></p> </li> <li> <p>access the item and add/overwrite a given (key, value) pair of the item <pre><code>set_up_test_data:\n  - reset_db\n  - create_testuser: !common-item \n    ID: TESTUSER # this is the ID as it appears in the common items YAML file\n    foo: 42 # overwrites the foo attribute\n</code></pre></p> </li> </ol>"},{"location":"manifest_specification/#yaml-aliases","title":"YAML aliases","text":"<p>[!WARNING] Aliases do not work as expected, especially when interacting with <code>!case</code> and <code>!common-items</code> tags, so don't use them. It's because YAML aliases are resolved before tags which are not \"transported\" in the alias.</p>"},{"location":"manifest_specification/#last-thoughts","title":"Last thoughts","text":"<p>The manifest specification provide different ways to avoid the repetition of information. As a consequence, there is not a unique manifest resulting in a given set of tests. Below are still some guidelines to choose how to write a manifest:</p> <ul> <li>Scene vs. Case: <ul> <li>Information describing the state/behavior of the app should be hard-coded in the scene. </li> <li>Information coming from the user's input should coded as a substituable field using <code>!case</code>.</li> <li>Information about content from the database may be coded as one or the other. Readability and maintainability should be your priority, then conciseness.</li> </ul> </li> </ul>"},{"location":"settings/","title":"Settings","text":"<p>Settings are stored in a specific module, by default at the root of the directory you are calling <code>scenery</code> from in a file called <code>scenery_settings.py</code>.</p> <p>If you prefer to use another naming convention or locate the file somewhere else, simply use the <code>--scenery_settings</code> option from the CLI.</p> <pre><code>python -m scenery --scenery_settings=path/to/scenery_settings.py --django_settings=your.dango.settings\n ```\n\n The file should look like this:\n\n```python\n# scenery_settings.py\nSCENERY_MANIFESTS_FOLDER = \"path/to/your/manifests\"\nSCENERY_COMMON_ITEMS = \"path/to/shared/data.yml\"\nSCENERY_SET_UP_INSTRUCTIONS = \"path/to/your/set_up_tear_down_functions\"\nSCENERY_TESTED_APP_NAME = \"your_app_name\"\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#test-manifests","title":"Test Manifests","text":"<p>With <code>scenery</code>, integration tests are configured using YAML, a human-readable data serialization language, making maintenance easy for developers. A given YAML file is called a manifest.</p> <p>In a manifest, a test is described by a scene which defines the request to a given URL and the checks (called directives) that should be applied to the HTTP response.</p>"},{"location":"usage/#example-1-simple-get-request","title":"Example 1: Simple GET request","text":"<pre><code>scene:\n  method: GET\n  url: \"index\"\n  directives:\n    - status_code: 200\n</code></pre> <p>This test sends a GET request to the '/index' URL and checks if the returned status code is 200.</p>"},{"location":"usage/#example-2-post-request-with-data","title":"Example 2: POST request with data","text":"<pre><code>cases:\n  CASE_A:\n    item_1:\n        foo: 0\n  CASE_B:\n    item_1:\n        foo: 1\n\nscene:\n  method: POST\n  url: \"item\"\n  data:\n    item_id: !case item_1:foo\n  directives:\n    - status_code: 200\n</code></pre> <p>This test sends a POST request to the '/item' URL with <code>{item_id: 0}</code> and <code>{item_id: 1}</code> as data and checks if the returned status code is 200.</p>"},{"location":"usage/#advanced-features","title":"Advanced Features","text":"<p>The full syntax of <code>scenery</code> allows you to:</p> <ul> <li>Test a given scene with different data sets</li> <li>Shared data for use across multiple tests</li> <li>Have full control over set-up </li> <li>Leverage YAML syntax to parsimonly define your tests</li> </ul> <p>See the full manifest specification for more details.</p>"},{"location":"usage/#settings","title":"Settings","text":"<p><code>scenery</code> relies on 4 environment variables, which can be easily provided by a <code>scenery_settings.py</code> file at the root of your project (or any location you prefer).</p> <p>You also need to provide the Django settings you want to use. Here's an example <code>scenery_settings.py</code>:</p> <pre><code># scenery_settings.py\nSCENERY_MANIFESTS_FOLDER = \"path/to/your/manifests\"\nSCENERY_COMMON_ITEMS = \"path/to/shared/data.yml\"\nSCENERY_SET_UP_INSTRUCTIONS = \"path/to/your/set_up_tear_down_functions\"\nSCENERY_TESTED_APP_NAME = \"your_app_name\"\n</code></pre>"},{"location":"usage/#running-tests","title":"Running Tests","text":"<p>To run your tests, use the following command:</p> <pre><code>python -m scenery --django_settings=your_project.settings.test\n</code></pre> <p>You can also add additional command-line arguments to filter tests, set verbosity, etc. Run <code>python -m scenery --help</code> for more information.</p>"},{"location":"examples/basic/","title":"Basic example","text":"<p>Assume you work on the following Django application.</p> <pre><code>\u2514\u2500\u2500 django_project\n    \u251c\u2500\u2500 db.sqlite3\n    \u251c\u2500\u2500 manage.py\n    \u251c\u2500\u2500 django_project\n    \u2502   \u251c\u2500\u2500 asgi.py\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 settings.py\n    \u2502   \u251c\u2500\u2500 urls.py\n    \u2502   \u2514\u2500\u2500 wsgi.py\n    \u2514\u2500\u2500 some_app\n        \u251c\u2500\u2500 admin.py\n        \u251c\u2500\u2500 apps.py\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 migrations\n        \u2502   \u2514\u2500\u2500 ...\n        \u251c\u2500\u2500 models.py\n        \u251c\u2500\u2500 tests\n        \u2502   \u2514\u2500\u2500  ...\n        \u2514\u2500\u2500 views.py\n</code></pre>"},{"location":"examples/basic/#scenery-files","title":"Scenery files","text":"<p>In order to use scenery, you could update your repo structure as below:</p> <pre><code>\u251c\u2500\u2500 django_project\n\u2502   \u251c\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 some_app\n\u2502       \u251c\u2500\u2500 tests\n\u2502       \u2502   \u251c\u2500\u2500 ...\n\u2502       \u2502   \u251c\u2500\u2500 common_items.yml\n\u2502       \u2502   \u251c\u2500\u2500 set_up_instructions.py\n\u2502       \u2502   \u2514\u2500\u2500 manifests\n\u2502       \u2502       \u2514\u2500\u2500 ...\n\u2502       \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 scenery_settings.py\n</code></pre>"},{"location":"examples/basic/#scenery-settings","title":"Scenery settings","text":"<p>The files gives you full control on any other folder structure you would prefer.</p> <pre><code># scenery_settings.py\nSCENERY_COMMON_ITEMS = \"projet_django/some_app/tests/common_items.yml\"\nSCENERY_SET_UP_INSTRUCTIONS = \"django_project.some_app.tests.set_up_instructions\"\nSCENERY_MANIFESTS_FOLDER = \"projet_django/some_app/tests/manifests\"\nSCENERY_TESTED_APP_NAME = \"some_app\"\n</code></pre>"},{"location":"examples/basic/#set-up-instructions","title":"Set up instructions","text":"<p>This file contains all actions you may want to execute in the <code>setUpTestData</code> or <code>setUp</code> testcase function. All functions shoul take <code>django_testcase: django.test.TestCase</code> as their first argument.</p> <pre><code># django_project/some_app/tests/set_up_instructions.py\n\ndef reset_db(django_testcase):\n    \"\"\"Reset your database.\"\"\"\n    ...\n\ndef create_test_user(\n        django_testcase, \n        *, \n        username, \n        field, \n        first_name, \n        last_name, \n        foo):\n    \"\"\"Create a new user in your database\"\"\"\n    ...\n</code></pre>"},{"location":"examples/basic/#common-items","title":"Common items","text":"<p>This file allows you to store data you want to use accross many tests. In this file, you can take full adavantage of the yaml syntax.</p> <pre><code># django_project/some_app/tests/common_items.yml\n\nEMAIL: &amp;email some@mail.com\nPASSWORD: &amp;password somepassword\n\nCREDENTIALS: &amp;credentials\n  username : *email\n  password : *password\n\nSOMEONE: &amp;someone\n  first_name : John\n  last_name : Doe\n\nTESTUSER:\n  &lt;&lt;: *credentials\n  &lt;&lt;: *someone\n  foo : bar\n</code></pre>"},{"location":"examples/basic/#adding-your-first-manifest","title":"Adding your first Manifest","text":"<p>Assume you want to test your login view</p> <pre><code># django_project/some_app/views.py\ndef login(request):\n    ...\n</code></pre> <p>You can now write a basic manifest that will check your view accepts an existing user and block if the provided credentials do not match what is in the database.</p> <pre><code># django_project/some_app/tests/manifests/login.yml\nset_up:\n  # Reset the database\n  - reset_db\n  # Create a test user based on credentials defined in \n  # django_project/some_app/tests/common_items.yml\n  - create_testuser: \n      !common-item TESTUSER\n\ncases:\n  # Case 1: correct credentials, we expect the 200 code status\n  success:\n    credentials: \n        !common-item CREDENTIALS # this is the ID as it appears in the common items YAML file\n    status_code: 200\n  # Case 2: wrong credentials, we expect the 401 code status\n  failure:\n    credentials: \n        !common-item # this syntax allows to add/overwrite attributes\n        ID: CREDENTIALS\n        password: wrongpassword\n    status_code: 401\n\nscene: \n  method: POST\n  url: app:login\n  data: !case credentials\n  directives:\n    - status_code: !case status_code\n</code></pre> <p>[!WARNING] Only a subset of YAML syntax is supported in the manifests. Please read the full manifest specification</p>"},{"location":"examples/basic/#run-your-tests","title":"Run your tests","text":"<p>You are now all set up to launch scenery!</p> <pre><code>python -m scenery --django_settings=project_dango.django_project.settings\n</code></pre> <p>Or add it in your CI workflow.</p>"}]}